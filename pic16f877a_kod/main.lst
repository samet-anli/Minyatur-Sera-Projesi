CCS PCM C Compiler, Version 5.007, 61971               21-Ara-22 12:20

               Filename:   C:\Users\Samet\OneDrive\Masaüstü\SERA_DOCS\TOPlaM\yeni1\main.lst

               ROM used:   4773 words (58%)
                           Largest free fragment is 2048
               RAM used:   77 (21%) at main() level
                           135 (37%) worst case
               Stack used: 1 locations (0 in main + 1 for interrupts)
               Stack size: 8

*
0000:  MOVLW  10
0001:  MOVWF  0A
0002:  GOTO   000
0003:  NOP
0004:  MOVWF  7F
0005:  SWAPF  03,W
0006:  CLRF   03
0007:  MOVWF  21
0008:  MOVF   0A,W
0009:  MOVWF  20
000A:  CLRF   0A
000B:  MOVF   04,W
000C:  MOVWF  22
000D:  MOVF   77,W
000E:  MOVWF  23
000F:  MOVF   78,W
0010:  MOVWF  24
0011:  MOVF   79,W
0012:  MOVWF  25
0013:  MOVF   7A,W
0014:  MOVWF  26
0015:  BCF    03.7
0016:  BCF    03.5
0017:  MOVLW  8C
0018:  MOVWF  04
0019:  BTFSS  00.5
001A:  GOTO   01D
001B:  BTFSC  0C.5
001C:  GOTO   032
001D:  BTFSS  0B.5
001E:  GOTO   021
001F:  BTFSC  0B.2
0020:  GOTO   035
0021:  MOVF   22,W
0022:  MOVWF  04
0023:  MOVF   23,W
0024:  MOVWF  77
0025:  MOVF   24,W
0026:  MOVWF  78
0027:  MOVF   25,W
0028:  MOVWF  79
0029:  MOVF   26,W
002A:  MOVWF  7A
002B:  MOVF   20,W
002C:  MOVWF  0A
002D:  SWAPF  21,W
002E:  MOVWF  03
002F:  SWAPF  7F,F
0030:  SWAPF  7F,W
0031:  RETFIE
0032:  BCF    0A.3
0033:  BCF    0A.4
0034:  GOTO   040
0035:  BCF    0A.3
0036:  BCF    0A.4
0037:  GOTO   41B
.................... #include <16F877A.h> 
.................... //////// Standard Header file for the PIC16F877A device //////////////// 
.................... #device PIC16F877A 
0038:  BCF    0A.0
0039:  BCF    0A.1
003A:  BCF    0A.2
003B:  ADDWF  02,F
003C:  RETLW  28
003D:  RETLW  0C
003E:  RETLW  01
003F:  RETLW  06
*
00FF:  MOVF   0B,W
0100:  BSF    03.5
0101:  MOVWF  2E
0102:  BCF    03.5
0103:  BCF    0B.7
0104:  BSF    03.5
0105:  BSF    03.6
0106:  BSF    0C.7
0107:  BSF    0C.0
0108:  NOP
0109:  NOP
010A:  BTFSC  03.0
010B:  GOTO   13B
010C:  BCF    03.5
010D:  MOVF   0C,W
010E:  ANDLW  7F
010F:  BSF    03.5
0110:  BCF    03.6
0111:  MOVWF  2F
0112:  BCF    03.5
0113:  BSF    03.6
0114:  MOVF   0D,W
0115:  BSF    03.5
0116:  BCF    03.6
0117:  MOVWF  30
0118:  BCF    03.5
0119:  BSF    03.6
011A:  MOVF   0F,W
011B:  BSF    03.5
011C:  BCF    03.6
011D:  MOVWF  31
011E:  MOVF   2F,W
011F:  BCF    03.5
0120:  BTFSS  0C.4
0121:  GOTO   120
0122:  MOVWF  19
0123:  BSF    03.5
0124:  MOVF   30,W
0125:  BCF    03.5
0126:  BSF    03.6
0127:  MOVWF  0D
0128:  BSF    03.5
0129:  BCF    03.6
012A:  MOVF   31,W
012B:  BCF    03.5
012C:  BSF    03.6
012D:  MOVWF  0F
012E:  BSF    03.5
012F:  BSF    0C.7
0130:  BSF    0C.0
0131:  NOP
0132:  NOP
0133:  BCF    03.6
0134:  DECFSZ 2D,F
0135:  GOTO   137
0136:  GOTO   139
0137:  BSF    03.6
0138:  GOTO   13B
0139:  GOTO   166
013A:  BSF    03.6
013B:  BCF    03.5
013C:  RLF    0C,W
013D:  RLF    0E,W
013E:  ANDLW  7F
013F:  BSF    03.5
0140:  BCF    03.6
0141:  MOVWF  2F
0142:  BCF    03.5
0143:  BSF    03.6
0144:  MOVF   0D,W
0145:  BSF    03.5
0146:  BCF    03.6
0147:  MOVWF  30
0148:  BCF    03.5
0149:  BSF    03.6
014A:  MOVF   0F,W
014B:  BSF    03.5
014C:  BCF    03.6
014D:  MOVWF  31
014E:  MOVF   2F,W
014F:  BCF    03.5
0150:  BTFSS  0C.4
0151:  GOTO   150
0152:  MOVWF  19
0153:  BSF    03.5
0154:  MOVF   30,W
0155:  BCF    03.5
0156:  BSF    03.6
0157:  MOVWF  0D
0158:  BSF    03.5
0159:  BCF    03.6
015A:  MOVF   31,W
015B:  BCF    03.5
015C:  BSF    03.6
015D:  MOVWF  0F
015E:  INCF   0D,F
015F:  BTFSC  03.2
0160:  INCF   0F,F
0161:  BCF    03.0
0162:  BSF    03.5
0163:  BCF    03.6
0164:  DECFSZ 2D,F
0165:  GOTO   105
0166:  BTFSS  2E.7
0167:  GOTO   16B
0168:  BCF    03.5
0169:  BSF    0B.7
016A:  BSF    03.5
016B:  BCF    03.5
016C:  RETURN
016D:  BSF    03.5
016E:  MOVF   34,W
016F:  CLRF   78
0170:  SUBWF  33,W
0171:  BTFSC  03.0
0172:  GOTO   176
0173:  MOVF   33,W
0174:  MOVWF  77
0175:  GOTO   182
0176:  CLRF   77
0177:  MOVLW  08
0178:  MOVWF  35
0179:  RLF    33,F
017A:  RLF    77,F
017B:  MOVF   34,W
017C:  SUBWF  77,W
017D:  BTFSC  03.0
017E:  MOVWF  77
017F:  RLF    78,F
0180:  DECFSZ 35,F
0181:  GOTO   179
0182:  BCF    03.5
0183:  RETURN
0184:  MOVLW  20
0185:  BSF    03.5
0186:  BTFSS  2E.4
0187:  MOVLW  30
0188:  MOVWF  2F
0189:  MOVF   2D,W
018A:  MOVWF  77
018B:  BTFSS  2D.7
018C:  GOTO   195
018D:  COMF   77,F
018E:  INCF   77,F
018F:  MOVF   77,W
0190:  MOVWF  2D
0191:  MOVLW  2D
0192:  MOVWF  2F
0193:  BSF    2E.7
0194:  BSF    2E.0
0195:  MOVF   2D,W
0196:  MOVWF  33
0197:  MOVLW  64
0198:  MOVWF  34
0199:  BCF    03.5
019A:  CALL   16D
019B:  MOVF   77,W
019C:  BSF    03.5
019D:  MOVWF  2D
019E:  MOVLW  30
019F:  ADDWF  78,W
01A0:  MOVWF  30
01A1:  MOVF   2D,W
01A2:  MOVWF  33
01A3:  MOVLW  0A
01A4:  MOVWF  34
01A5:  BCF    03.5
01A6:  CALL   16D
01A7:  MOVLW  30
01A8:  ADDWF  77,W
01A9:  BSF    03.5
01AA:  MOVWF  32
01AB:  MOVLW  30
01AC:  ADDWF  78,W
01AD:  MOVWF  31
01AE:  MOVF   2F,W
01AF:  MOVWF  77
01B0:  MOVLW  30
01B1:  SUBWF  30,W
01B2:  BTFSC  03.2
01B3:  GOTO   1B8
01B4:  BSF    2E.1
01B5:  BTFSC  2E.7
01B6:  BSF    2E.2
01B7:  GOTO   1CC
01B8:  MOVF   2F,W
01B9:  MOVWF  30
01BA:  MOVLW  20
01BB:  MOVWF  2F
01BC:  MOVLW  30
01BD:  SUBWF  31,W
01BE:  BTFSC  03.2
01BF:  GOTO   1C4
01C0:  BSF    2E.0
01C1:  BTFSC  2E.7
01C2:  BSF    2E.1
01C3:  GOTO   1CC
01C4:  BTFSS  03.2
01C5:  BSF    2E.0
01C6:  BTFSS  03.2
01C7:  GOTO   1CC
01C8:  MOVF   30,W
01C9:  MOVWF  31
01CA:  MOVLW  20
01CB:  MOVWF  30
01CC:  BTFSC  2E.2
01CD:  GOTO   1D3
01CE:  BTFSC  2E.1
01CF:  GOTO   1D9
01D0:  BTFSC  2E.0
01D1:  GOTO   1DF
01D2:  GOTO   1E5
01D3:  MOVF   2F,W
01D4:  BCF    03.5
01D5:  BTFSS  0C.4
01D6:  GOTO   1D5
01D7:  MOVWF  19
01D8:  BSF    03.5
01D9:  MOVF   30,W
01DA:  BCF    03.5
01DB:  BTFSS  0C.4
01DC:  GOTO   1DB
01DD:  MOVWF  19
01DE:  BSF    03.5
01DF:  MOVF   31,W
01E0:  BCF    03.5
01E1:  BTFSS  0C.4
01E2:  GOTO   1E1
01E3:  MOVWF  19
01E4:  BSF    03.5
01E5:  MOVF   32,W
01E6:  BCF    03.5
01E7:  BTFSS  0C.4
01E8:  GOTO   1E7
01E9:  MOVWF  19
01EA:  RETURN
01EB:  MOVF   0B,W
01EC:  BSF    03.5
01ED:  MOVWF  2D
01EE:  BCF    03.5
01EF:  BCF    0B.7
01F0:  BSF    03.5
01F1:  BSF    03.6
01F2:  BSF    0C.7
01F3:  BSF    0C.0
01F4:  NOP
01F5:  NOP
01F6:  BCF    03.5
01F7:  MOVF   0C,W
01F8:  ANDLW  7F
01F9:  BTFSC  03.2
01FA:  GOTO   24A
01FB:  BSF    03.5
01FC:  BCF    03.6
01FD:  MOVWF  2E
01FE:  BCF    03.5
01FF:  BSF    03.6
0200:  MOVF   0D,W
0201:  BSF    03.5
0202:  BCF    03.6
0203:  MOVWF  2F
0204:  BCF    03.5
0205:  BSF    03.6
0206:  MOVF   0F,W
0207:  BSF    03.5
0208:  BCF    03.6
0209:  MOVWF  30
020A:  MOVF   2E,W
020B:  BCF    03.5
020C:  BTFSS  0C.4
020D:  GOTO   20C
020E:  MOVWF  19
020F:  BSF    03.5
0210:  MOVF   2F,W
0211:  BCF    03.5
0212:  BSF    03.6
0213:  MOVWF  0D
0214:  BSF    03.5
0215:  BCF    03.6
0216:  MOVF   30,W
0217:  BCF    03.5
0218:  BSF    03.6
0219:  MOVWF  0F
021A:  BSF    03.5
021B:  BSF    0C.7
021C:  BSF    0C.0
021D:  NOP
021E:  NOP
021F:  BCF    03.5
0220:  RLF    0C,W
0221:  RLF    0E,W
0222:  ANDLW  7F
0223:  BTFSC  03.2
0224:  GOTO   24A
0225:  BSF    03.5
0226:  BCF    03.6
0227:  MOVWF  2E
0228:  BCF    03.5
0229:  BSF    03.6
022A:  MOVF   0D,W
022B:  BSF    03.5
022C:  BCF    03.6
022D:  MOVWF  2F
022E:  BCF    03.5
022F:  BSF    03.6
0230:  MOVF   0F,W
0231:  BSF    03.5
0232:  BCF    03.6
0233:  MOVWF  30
0234:  MOVF   2E,W
0235:  BCF    03.5
0236:  BTFSS  0C.4
0237:  GOTO   236
0238:  MOVWF  19
0239:  BSF    03.5
023A:  MOVF   2F,W
023B:  BCF    03.5
023C:  BSF    03.6
023D:  MOVWF  0D
023E:  BSF    03.5
023F:  BCF    03.6
0240:  MOVF   30,W
0241:  BCF    03.5
0242:  BSF    03.6
0243:  MOVWF  0F
0244:  INCF   0D,F
0245:  BTFSC  03.2
0246:  INCF   0F,F
0247:  BCF    03.6
0248:  GOTO   1F0
0249:  BSF    03.6
024A:  BSF    03.5
024B:  BCF    03.6
024C:  BTFSS  2D.7
024D:  GOTO   251
024E:  BCF    03.5
024F:  BSF    0B.7
0250:  BSF    03.5
0251:  BCF    03.5
0252:  RETURN
0253:  BSF    03.5
0254:  MOVF   3A,W
0255:  BTFSC  03.2
0256:  GOTO   2C4
0257:  MOVWF  42
0258:  MOVF   3E,W
0259:  BTFSC  03.2
025A:  GOTO   2C4
025B:  ADDWF  42,F
025C:  BTFSC  03.0
025D:  GOTO   265
025E:  MOVLW  7F
025F:  SUBWF  42,F
0260:  BTFSS  03.0
0261:  GOTO   2C4
0262:  BTFSC  03.2
0263:  GOTO   2C4
0264:  GOTO   269
0265:  MOVLW  81
0266:  ADDWF  42,F
0267:  BTFSC  03.0
0268:  GOTO   2C4
0269:  MOVF   42,W
026A:  MOVWF  77
026B:  CLRF   78
026C:  CLRF   79
026D:  CLRF   7A
026E:  MOVF   3B,W
026F:  MOVWF  46
0270:  BSF    46.7
0271:  MOVF   3C,W
0272:  MOVWF  45
0273:  MOVF   3D,W
0274:  MOVWF  44
0275:  MOVLW  18
0276:  MOVWF  42
0277:  CLRF   43
0278:  BTFSS  44.0
0279:  GOTO   292
027A:  MOVF   41,W
027B:  ADDWF  7A,F
027C:  BTFSS  03.0
027D:  GOTO   284
027E:  INCF   79,F
027F:  BTFSS  03.2
0280:  GOTO   284
0281:  INCF   78,F
0282:  BTFSC  03.2
0283:  BSF    43.7
0284:  MOVF   40,W
0285:  ADDWF  79,F
0286:  BTFSS  03.0
0287:  GOTO   28B
0288:  INCF   78,F
0289:  BTFSC  03.2
028A:  BSF    43.7
028B:  MOVF   3F,W
028C:  MOVWF  3C
028D:  BSF    3C.7
028E:  MOVF   3C,W
028F:  ADDWF  78,F
0290:  BTFSC  03.0
0291:  BSF    43.7
0292:  RLF    43,F
0293:  RRF    78,F
0294:  RRF    79,F
0295:  RRF    7A,F
0296:  RRF    46,F
0297:  RRF    45,F
0298:  RRF    44,F
0299:  BCF    03.0
029A:  DECFSZ 42,F
029B:  GOTO   277
029C:  MOVLW  01
029D:  ADDWF  77,F
029E:  BTFSC  03.0
029F:  GOTO   2C4
02A0:  BTFSC  78.7
02A1:  GOTO   2A9
02A2:  RLF    46,F
02A3:  RLF    7A,F
02A4:  RLF    79,F
02A5:  RLF    78,F
02A6:  DECF   77,F
02A7:  BTFSC  03.2
02A8:  GOTO   2C4
02A9:  BTFSS  46.7
02AA:  GOTO   2BA
02AB:  INCF   7A,F
02AC:  BTFSS  03.2
02AD:  GOTO   2BA
02AE:  INCF   79,F
02AF:  BTFSS  03.2
02B0:  GOTO   2BA
02B1:  INCF   78,F
02B2:  BTFSS  03.2
02B3:  GOTO   2BA
02B4:  RRF    78,F
02B5:  RRF    79,F
02B6:  RRF    7A,F
02B7:  INCF   77,F
02B8:  BTFSC  03.2
02B9:  GOTO   2C4
02BA:  MOVF   3B,W
02BB:  MOVWF  43
02BC:  MOVF   3F,W
02BD:  XORWF  43,F
02BE:  BTFSS  43.7
02BF:  GOTO   2C2
02C0:  BSF    78.7
02C1:  GOTO   2C8
02C2:  BCF    78.7
02C3:  GOTO   2C8
02C4:  CLRF   77
02C5:  CLRF   78
02C6:  CLRF   79
02C7:  CLRF   7A
02C8:  BCF    03.5
02C9:  RETURN
02CA:  BSF    03.5
02CB:  MOVF   3A,W
02CC:  SUBLW  B6
02CD:  MOVWF  3A
02CE:  CLRF   7A
02CF:  MOVF   3B,W
02D0:  MOVWF  3E
02D1:  BSF    3B.7
02D2:  BCF    03.0
02D3:  RRF    3B,F
02D4:  RRF    3C,F
02D5:  RRF    3D,F
02D6:  RRF    7A,F
02D7:  RRF    79,F
02D8:  RRF    78,F
02D9:  RRF    77,F
02DA:  DECFSZ 3A,F
02DB:  GOTO   2D2
02DC:  BTFSS  3E.7
02DD:  GOTO   2E9
02DE:  COMF   77,F
02DF:  COMF   78,F
02E0:  COMF   79,F
02E1:  COMF   7A,F
02E2:  INCF   77,F
02E3:  BTFSC  03.2
02E4:  INCF   78,F
02E5:  BTFSC  03.2
02E6:  INCF   79,F
02E7:  BTFSC  03.2
02E8:  INCF   7A,F
02E9:  BCF    03.5
02EA:  RETURN
02EB:  BTFSC  03.1
02EC:  GOTO   2F0
02ED:  MOVLW  C2
02EE:  MOVWF  04
02EF:  BCF    03.7
02F0:  CLRF   77
02F1:  CLRF   78
02F2:  CLRF   79
02F3:  CLRF   7A
02F4:  BSF    03.5
02F5:  CLRF   42
02F6:  CLRF   43
02F7:  CLRF   44
02F8:  CLRF   45
02F9:  MOVF   41,W
02FA:  IORWF  40,W
02FB:  IORWF  3F,W
02FC:  IORWF  3E,W
02FD:  BTFSC  03.2
02FE:  GOTO   32F
02FF:  MOVLW  20
0300:  MOVWF  46
0301:  BCF    03.0
0302:  RLF    3A,F
0303:  RLF    3B,F
0304:  RLF    3C,F
0305:  RLF    3D,F
0306:  RLF    42,F
0307:  RLF    43,F
0308:  RLF    44,F
0309:  RLF    45,F
030A:  MOVF   41,W
030B:  SUBWF  45,W
030C:  BTFSS  03.2
030D:  GOTO   318
030E:  MOVF   40,W
030F:  SUBWF  44,W
0310:  BTFSS  03.2
0311:  GOTO   318
0312:  MOVF   3F,W
0313:  SUBWF  43,W
0314:  BTFSS  03.2
0315:  GOTO   318
0316:  MOVF   3E,W
0317:  SUBWF  42,W
0318:  BTFSS  03.0
0319:  GOTO   329
031A:  MOVF   3E,W
031B:  SUBWF  42,F
031C:  MOVF   3F,W
031D:  BTFSS  03.0
031E:  INCFSZ 3F,W
031F:  SUBWF  43,F
0320:  MOVF   40,W
0321:  BTFSS  03.0
0322:  INCFSZ 40,W
0323:  SUBWF  44,F
0324:  MOVF   41,W
0325:  BTFSS  03.0
0326:  INCFSZ 41,W
0327:  SUBWF  45,F
0328:  BSF    03.0
0329:  RLF    77,F
032A:  RLF    78,F
032B:  RLF    79,F
032C:  RLF    7A,F
032D:  DECFSZ 46,F
032E:  GOTO   301
032F:  MOVF   42,W
0330:  MOVWF  00
0331:  INCF   04,F
0332:  MOVF   43,W
0333:  MOVWF  00
0334:  INCF   04,F
0335:  MOVF   44,W
0336:  MOVWF  00
0337:  INCF   04,F
0338:  MOVF   45,W
0339:  MOVWF  00
033A:  BCF    03.5
033B:  RETURN
033C:  MOVF   04,W
033D:  BSF    03.5
033E:  MOVWF  32
033F:  MOVF   31,W
0340:  MOVWF  34
0341:  BTFSC  03.2
0342:  GOTO   35E
0343:  MOVF   30,W
0344:  MOVWF  3D
0345:  MOVF   2F,W
0346:  MOVWF  3C
0347:  MOVF   2E,W
0348:  MOVWF  3B
0349:  MOVF   2D,W
034A:  MOVWF  3A
034B:  CLRF   41
034C:  CLRF   40
034D:  MOVLW  20
034E:  MOVWF  3F
034F:  MOVLW  82
0350:  MOVWF  3E
0351:  BCF    03.5
0352:  CALL   253
0353:  MOVF   7A,W
0354:  BSF    03.5
0355:  MOVWF  30
0356:  MOVF   79,W
0357:  MOVWF  2F
0358:  MOVF   78,W
0359:  MOVWF  2E
035A:  MOVF   77,W
035B:  MOVWF  2D
035C:  DECFSZ 34,F
035D:  GOTO   343
035E:  MOVF   30,W
035F:  MOVWF  3D
0360:  MOVF   2F,W
0361:  MOVWF  3C
0362:  MOVF   2E,W
0363:  MOVWF  3B
0364:  MOVF   2D,W
0365:  MOVWF  3A
0366:  BCF    03.5
0367:  CALL   2CA
0368:  MOVF   7A,W
0369:  BSF    03.5
036A:  MOVWF  30
036B:  MOVF   79,W
036C:  MOVWF  2F
036D:  MOVF   78,W
036E:  MOVWF  2E
036F:  MOVF   77,W
0370:  MOVWF  2D
0371:  BTFSS  30.7
0372:  GOTO   380
0373:  DECF   32,F
0374:  BSF    32.5
0375:  COMF   2D,F
0376:  COMF   2E,F
0377:  COMF   2F,F
0378:  COMF   30,F
0379:  INCF   2D,F
037A:  BTFSC  03.2
037B:  INCF   2E,F
037C:  BTFSC  03.2
037D:  INCF   2F,F
037E:  BTFSC  03.2
037F:  INCF   30,F
0380:  MOVLW  3B
0381:  MOVWF  39
0382:  MOVLW  9A
0383:  MOVWF  38
0384:  MOVLW  CA
0385:  MOVWF  37
0386:  CLRF   36
0387:  MOVLW  0A
0388:  MOVWF  34
0389:  MOVF   31,W
038A:  BTFSC  03.2
038B:  INCF   32,F
038C:  BSF    03.1
038D:  MOVLW  AD
038E:  MOVWF  04
038F:  BCF    03.7
0390:  MOVF   30,W
0391:  MOVWF  3D
0392:  MOVF   2F,W
0393:  MOVWF  3C
0394:  MOVF   2E,W
0395:  MOVWF  3B
0396:  MOVF   2D,W
0397:  MOVWF  3A
0398:  MOVF   39,W
0399:  MOVWF  41
039A:  MOVF   38,W
039B:  MOVWF  40
039C:  MOVF   37,W
039D:  MOVWF  3F
039E:  MOVF   36,W
039F:  MOVWF  3E
03A0:  BCF    03.5
03A1:  CALL   2EB
03A2:  MOVF   78,W
03A3:  MOVF   77,F
03A4:  BTFSS  03.2
03A5:  GOTO   3BD
03A6:  BSF    03.5
03A7:  INCF   31,W
03A8:  SUBWF  34,W
03A9:  BTFSS  03.2
03AA:  GOTO   3AD
03AB:  BCF    03.5
03AC:  GOTO   3BD
03AD:  MOVF   32,W
03AE:  BTFSC  03.2
03AF:  GOTO   3C0
03B0:  ANDLW  0F
03B1:  SUBWF  34,W
03B2:  BTFSC  03.2
03B3:  GOTO   3B6
03B4:  BTFSC  03.0
03B5:  GOTO   3FC
03B6:  BTFSC  32.7
03B7:  GOTO   3FC
03B8:  BTFSC  32.6
03B9:  GOTO   3C0
03BA:  MOVLW  20
03BB:  GOTO   3F5
03BC:  BCF    03.5
03BD:  MOVLW  20
03BE:  BSF    03.5
03BF:  ANDWF  32,F
03C0:  BTFSS  32.5
03C1:  GOTO   3D1
03C2:  BCF    32.5
03C3:  MOVF   31,W
03C4:  BTFSS  03.2
03C5:  DECF   32,F
03C6:  MOVF   77,W
03C7:  MOVWF  32
03C8:  MOVLW  2D
03C9:  BCF    03.5
03CA:  BTFSS  0C.4
03CB:  GOTO   3CA
03CC:  MOVWF  19
03CD:  BSF    03.5
03CE:  MOVF   32,W
03CF:  MOVWF  77
03D0:  CLRF   32
03D1:  MOVF   31,W
03D2:  SUBWF  34,W
03D3:  BTFSS  03.2
03D4:  GOTO   3E2
03D5:  MOVF   77,W
03D6:  MOVWF  32
03D7:  MOVLW  2E
03D8:  BCF    03.5
03D9:  BTFSS  0C.4
03DA:  GOTO   3D9
03DB:  MOVWF  19
03DC:  BSF    03.5
03DD:  MOVF   32,W
03DE:  MOVWF  77
03DF:  MOVLW  20
03E0:  ANDWF  32,F
03E1:  MOVLW  00
03E2:  MOVLW  30
03E3:  BTFSS  32.5
03E4:  GOTO   3F5
03E5:  BCF    32.5
03E6:  MOVF   31,W
03E7:  BTFSS  03.2
03E8:  DECF   32,F
03E9:  MOVF   77,W
03EA:  MOVWF  32
03EB:  MOVLW  2D
03EC:  BCF    03.5
03ED:  BTFSS  0C.4
03EE:  GOTO   3ED
03EF:  MOVWF  19
03F0:  BSF    03.5
03F1:  MOVF   32,W
03F2:  MOVWF  77
03F3:  CLRF   32
03F4:  MOVLW  30
03F5:  ADDWF  77,F
03F6:  MOVF   77,W
03F7:  BCF    03.5
03F8:  BTFSS  0C.4
03F9:  GOTO   3F8
03FA:  MOVWF  19
03FB:  BSF    03.5
03FC:  BCF    03.1
03FD:  MOVF   39,W
03FE:  MOVWF  3D
03FF:  MOVF   38,W
0400:  MOVWF  3C
0401:  MOVF   37,W
0402:  MOVWF  3B
0403:  MOVF   36,W
0404:  MOVWF  3A
0405:  CLRF   41
0406:  CLRF   40
0407:  CLRF   3F
0408:  MOVLW  0A
0409:  MOVWF  3E
040A:  BCF    03.5
040B:  CALL   2EB
040C:  MOVF   7A,W
040D:  BSF    03.5
040E:  MOVWF  39
040F:  MOVF   79,W
0410:  MOVWF  38
0411:  MOVF   78,W
0412:  MOVWF  37
0413:  MOVF   77,W
0414:  MOVWF  36
0415:  DECFSZ 34,F
0416:  GOTO   38C
0417:  BCF    03.5
0418:  BCF    0A.3
0419:  BCF    0A.4
041A:  GOTO   486 (RETURN)
*
04F3:  DATA D3,3A
04F4:  DATA A0,29
04F5:  DATA 65,3B
04F6:  DATA E9,3C
04F7:  DATA 65,1D
04F8:  DATA A0,12
04F9:  DATA E3,12
04FA:  DATA 64,05
04FB:  DATA 00,00
04FC:  DATA D4,37
04FD:  DATA 70,39
04FE:  DATA E1,35
04FF:  DATA A0,16
0500:  DATA AD,16
0501:  DATA AD,16
0502:  DATA AD,16
0503:  DATA 00,00
0504:  DATA CE,32
0505:  DATA 6D,10
0506:  DATA 20,10
0507:  DATA 20,10
0508:  DATA 20,1D
0509:  DATA A5,31
050A:  DATA 25,32
050B:  DATA 0A,00
050C:  DATA D3,34
050D:  DATA E3,30
050E:  DATA 6B,36
050F:  DATA E9,35
0510:  DATA BA,12
0511:  DATA E6,21
0512:  DATA 20,00
0513:  DATA AD,16
0514:  DATA AD,16
0515:  DATA AD,16
0516:  DATA AD,16
0517:  DATA AD,16
0518:  DATA AD,16
0519:  DATA AD,16
051A:  DATA AD,16
051B:  DATA 00,01
051C:  DATA C8,30
051D:  DATA F6,30
051E:  DATA A0,16
051F:  DATA AD,16
0520:  DATA AD,16
0521:  DATA AD,16
0522:  DATA AD,16
0523:  DATA 00,01
0524:  DATA CE,32
0525:  DATA 6D,10
0526:  DATA 20,10
0527:  DATA 20,10
0528:  DATA 20,1D
0529:  DATA A5,31
052A:  DATA 25,32
052B:  DATA 0A,00
052C:  DATA D3,34
052D:  DATA E3,30
052E:  DATA 6B,36
052F:  DATA E9,35
0530:  DATA BA,12
0531:  DATA E4,21
0532:  DATA 00,01
0533:  DATA AD,16
0534:  DATA AD,16
0535:  DATA AD,16
0536:  DATA AD,16
0537:  DATA AD,16
0538:  DATA AD,16
0539:  DATA AD,16
053A:  DATA AD,16
053B:  DATA 00,01
053C:  DATA C9,39
053D:  DATA E9,35
053E:  DATA A0,29
053F:  DATA 69,32
0540:  DATA E4,32
0541:  DATA F4,34
0542:  DATA 3A,10
0543:  DATA 25,32
0544:  DATA 00,01
0545:  DATA AD,16
0546:  DATA AD,16
0547:  DATA AD,16
0548:  DATA AD,16
0549:  DATA AD,16
054A:  DATA AD,16
054B:  DATA AD,16
054C:  DATA 00,00
054D:  DATA 20,10
054E:  DATA 2A,15
054F:  DATA 20,10
0550:  DATA D3,22
0551:  DATA D2,20
0552:  DATA 20,10
0553:  DATA 2A,15
0554:  DATA 20,10
0555:  DATA 00,00
0556:  DATA 0A,10
0557:  DATA 20,10
0558:  DATA 4F,2A
0559:  DATA CF,26
055A:  DATA C1,29
055B:  DATA D9,27
055C:  DATA CE,2A
055D:  DATA 20,10
055E:  DATA 20,00
055F:  DATA C2,30
0560:  DATA 73,36
0561:  DATA E9,3C
0562:  DATA 6F,39
0563:  DATA 2E,17
0564:  DATA 2E,00
0565:  DATA C2,30
0566:  DATA 73,36
0567:  DATA E9,3C
0568:  DATA 6F,39
0569:  DATA B1,32
056A:  DATA 65,17
056B:  DATA 2E,17
056C:  DATA 00,01
056D:  DATA C2,30
056E:  DATA 73,36
056F:  DATA E9,3C
0570:  DATA 6F,39
0571:  DATA B2,39
0572:  DATA 74,17
0573:  DATA 2E,17
0574:  DATA 00,01
0575:  DATA 64,34
0576:  DATA F4,18
0577:  DATA 72,17
0578:  DATA 2E,17
0579:  DATA 00,01
057A:  DATA D4,34
057B:  DATA ED,32
057C:  DATA A0,37
057D:  DATA 75,3A
057E:  DATA 21,00
057F:  DATA 64,34
0580:  DATA 74,19
0581:  DATA 2E,17
0582:  DATA 2E,00
0583:  DATA 43,34
0584:  DATA E5,31
0585:  DATA EB,39
0586:  DATA F5,36
0587:  DATA A0,22
0588:  DATA 72,39
0589:  DATA 6F,39
058A:  DATA 21,00
058B:  DATA CE,37
058C:  DATA 20,39
058D:  DATA E5,39
058E:  DATA F0,37
058F:  DATA EE,39
0590:  DATA 65,00
0591:  DATA 66,39
0592:  DATA EF,36
0593:  DATA 20,3A
0594:  DATA E8,32
0595:  DATA 20,22
0596:  DATA 48,2A
0597:  DATA B1,18
0598:  DATA 00,01
0599:  DATA D3,2A
059A:  DATA 20,22
059B:  DATA 45,28
059C:  DATA CF,29
059D:  DATA 55,10
059E:  DATA D3,22
059F:  DATA D6,24
05A0:  DATA D9,22
05A1:  DATA 00,01
05A2:  DATA 25,00
05A3:  DATA D4,27
05A4:  DATA 50,29
05A5:  DATA C1,25
05A6:  DATA 20,27
05A7:  DATA C5,26
05A8:  DATA 3A,00
05A9:  DATA A0,12
05AA:  DATA 00,01
05AB:  DATA D3,24
05AC:  DATA C3,20
05AD:  DATA 4B,26
05AE:  DATA C9,25
05AF:  DATA BA,12
05B0:  DATA E6,12
05B1:  DATA E3,21
05B2:  DATA 00,00
05B3:  DATA A0,22
05B4:  DATA 72,39
05B5:  DATA 6F,39
05B6:  DATA 21,10
05B7:  DATA 00,00
05B8:  DATA 20,10
05B9:  DATA C9,29
05BA:  DATA C9,25
05BB:  DATA A0,29
05BC:  DATA 49,22
05BD:  DATA C4,22
05BE:  DATA D4,24
05BF:  DATA 00,01
05C0:  DATA BA,12
05C1:  DATA 64,10
05C2:  DATA C4,3A
05C3:  DATA F2,3A
05C4:  DATA 6D,1D
05C5:  DATA A5,31
05C6:  DATA A5,31
05C7:  DATA A5,31
05C8:  DATA 00,01
05C9:  DATA C2,34
05CA:  DATA F4,35
05CB:  DATA 69,10
05CC:  DATA D3,32
05CD:  DATA E3,34
05CE:  DATA ED,34
05CF:  DATA 8A,2C
05D0:  DATA 61,38
05D1:  DATA 69,37
05D2:  DATA 69,3D
05D3:  DATA 2E,17
05D4:  DATA 2E,00
*
0726:  MOVF   0B,W
0727:  MOVWF  65
0728:  BCF    0B.7
0729:  BSF    03.5
072A:  BSF    03.6
072B:  BSF    0C.7
072C:  BSF    0C.0
072D:  NOP
072E:  NOP
072F:  BCF    03.5
0730:  MOVF   0C,W
0731:  ANDLW  7F
0732:  BTFSC  03.2
0733:  GOTO   76D
0734:  BCF    03.6
0735:  MOVWF  66
0736:  BSF    03.6
0737:  MOVF   0D,W
0738:  BCF    03.6
0739:  MOVWF  67
073A:  BSF    03.6
073B:  MOVF   0F,W
073C:  BCF    03.6
073D:  MOVWF  68
073E:  MOVF   66,W
073F:  MOVWF  72
0740:  CALL   702
0741:  MOVF   67,W
0742:  BSF    03.6
0743:  MOVWF  0D
0744:  BCF    03.6
0745:  MOVF   68,W
0746:  BSF    03.6
0747:  MOVWF  0F
0748:  BSF    03.5
0749:  BSF    0C.7
074A:  BSF    0C.0
074B:  NOP
074C:  NOP
074D:  BCF    03.5
074E:  RLF    0C,W
074F:  RLF    0E,W
0750:  ANDLW  7F
0751:  BTFSC  03.2
0752:  GOTO   76D
0753:  BCF    03.6
0754:  MOVWF  66
0755:  BSF    03.6
0756:  MOVF   0D,W
0757:  BCF    03.6
0758:  MOVWF  67
0759:  BSF    03.6
075A:  MOVF   0F,W
075B:  BCF    03.6
075C:  MOVWF  68
075D:  MOVF   66,W
075E:  MOVWF  72
075F:  CALL   702
0760:  MOVF   67,W
0761:  BSF    03.6
0762:  MOVWF  0D
0763:  BCF    03.6
0764:  MOVF   68,W
0765:  BSF    03.6
0766:  MOVWF  0F
0767:  INCF   0D,F
0768:  BTFSC  03.2
0769:  INCF   0F,F
076A:  BCF    03.6
076B:  GOTO   729
076C:  BSF    03.6
076D:  BCF    03.6
076E:  BTFSC  65.7
076F:  BSF    0B.7
0770:  RETURN
*
0785:  MOVLW  8E
0786:  MOVWF  77
0787:  MOVF   68,W
0788:  MOVWF  78
0789:  MOVF   67,W
078A:  MOVWF  79
078B:  CLRF   7A
078C:  MOVF   78,F
078D:  BTFSS  03.2
078E:  GOTO   799
078F:  MOVF   79,W
0790:  MOVWF  78
0791:  CLRF   79
0792:  MOVLW  08
0793:  SUBWF  77,F
0794:  MOVF   78,F
0795:  BTFSS  03.2
0796:  GOTO   799
0797:  CLRF   77
0798:  GOTO   7A1
0799:  BCF    03.0
079A:  BTFSC  78.7
079B:  GOTO   7A0
079C:  RLF    79,F
079D:  RLF    78,F
079E:  DECF   77,F
079F:  GOTO   799
07A0:  BCF    78.7
07A1:  RETURN
07A2:  MOVLW  8E
07A3:  MOVWF  77
07A4:  MOVF   65,W
07A5:  SUBWF  77,F
07A6:  MOVF   66,W
07A7:  MOVWF  79
07A8:  MOVF   67,W
07A9:  MOVWF  78
07AA:  BSF    79.7
07AB:  MOVF   77,F
07AC:  BTFSC  03.2
07AD:  GOTO   7B9
07AE:  BCF    03.0
07AF:  MOVF   79,F
07B0:  BTFSS  03.2
07B1:  GOTO   7B5
07B2:  MOVF   78,F
07B3:  BTFSC  03.2
07B4:  GOTO   7B9
07B5:  RRF    79,F
07B6:  RRF    78,F
07B7:  DECFSZ 77,F
07B8:  GOTO   7AE
07B9:  BTFSS  66.7
07BA:  GOTO   7C0
07BB:  COMF   78,F
07BC:  COMF   79,F
07BD:  INCF   78,F
07BE:  BTFSC  03.2
07BF:  INCF   79,F
07C0:  RETURN
*
08BE:  MOVLW  8E
08BF:  MOVWF  77
08C0:  MOVF   66,W
08C1:  MOVWF  78
08C2:  MOVF   65,W
08C3:  MOVWF  79
08C4:  CLRF   7A
08C5:  BTFSS  66.7
08C6:  GOTO   0CC
08C7:  COMF   78,F
08C8:  COMF   79,F
08C9:  INCF   79,F
08CA:  BTFSC  03.2
08CB:  INCF   78,F
08CC:  MOVF   78,F
08CD:  BTFSS  03.2
08CE:  GOTO   0D9
08CF:  MOVF   79,W
08D0:  MOVWF  78
08D1:  CLRF   79
08D2:  MOVLW  08
08D3:  SUBWF  77,F
08D4:  MOVF   78,F
08D5:  BTFSS  03.2
08D6:  GOTO   0D9
08D7:  CLRF   77
08D8:  GOTO   0E2
08D9:  BCF    03.0
08DA:  BTFSC  78.7
08DB:  GOTO   0E0
08DC:  RLF    79,F
08DD:  RLF    78,F
08DE:  DECF   77,F
08DF:  GOTO   0D9
08E0:  BTFSS  66.7
08E1:  BCF    78.7
08E2:  BCF    0A.3
08E3:  BSF    0A.4
08E4:  GOTO   293 (RETURN)
08E5:  MOVF   69,W
08E6:  BTFSC  03.2
08E7:  GOTO   1AA
08E8:  MOVWF  75
08E9:  MOVF   6D,W
08EA:  BTFSC  03.2
08EB:  GOTO   1AA
08EC:  SUBWF  75,F
08ED:  BTFSS  03.0
08EE:  GOTO   0F4
08EF:  MOVLW  7F
08F0:  ADDWF  75,F
08F1:  BTFSC  03.0
08F2:  GOTO   1AA
08F3:  GOTO   0FA
08F4:  MOVLW  81
08F5:  SUBWF  75,F
08F6:  BTFSS  03.0
08F7:  GOTO   1AA
08F8:  BTFSC  03.2
08F9:  GOTO   1AA
08FA:  MOVF   75,W
08FB:  MOVWF  77
08FC:  CLRF   78
08FD:  CLRF   79
08FE:  CLRF   7A
08FF:  CLRF   74
0900:  MOVF   6A,W
0901:  MOVWF  73
0902:  BSF    73.7
0903:  MOVF   6B,W
0904:  MOVWF  72
0905:  MOVF   6C,W
0906:  MOVWF  71
0907:  MOVLW  19
0908:  MOVWF  75
0909:  MOVF   70,W
090A:  SUBWF  71,F
090B:  BTFSC  03.0
090C:  GOTO   11D
090D:  MOVLW  01
090E:  SUBWF  72,F
090F:  BTFSC  03.0
0910:  GOTO   11D
0911:  SUBWF  73,F
0912:  BTFSC  03.0
0913:  GOTO   11D
0914:  SUBWF  74,F
0915:  BTFSC  03.0
0916:  GOTO   11D
0917:  INCF   74,F
0918:  INCF   73,F
0919:  INCF   72,F
091A:  MOVF   70,W
091B:  ADDWF  71,F
091C:  GOTO   14F
091D:  MOVF   6F,W
091E:  SUBWF  72,F
091F:  BTFSC  03.0
0920:  GOTO   138
0921:  MOVLW  01
0922:  SUBWF  73,F
0923:  BTFSC  03.0
0924:  GOTO   138
0925:  SUBWF  74,F
0926:  BTFSC  03.0
0927:  GOTO   138
0928:  INCF   74,F
0929:  INCF   73,F
092A:  MOVF   6F,W
092B:  ADDWF  72,F
092C:  MOVF   70,W
092D:  ADDWF  71,F
092E:  BTFSS  03.0
092F:  GOTO   14F
0930:  INCF   72,F
0931:  BTFSS  03.2
0932:  GOTO   14F
0933:  INCF   73,F
0934:  BTFSS  03.2
0935:  GOTO   14F
0936:  INCF   74,F
0937:  GOTO   14F
0938:  MOVF   6E,W
0939:  IORLW  80
093A:  SUBWF  73,F
093B:  BTFSC  03.0
093C:  GOTO   14E
093D:  MOVLW  01
093E:  SUBWF  74,F
093F:  BTFSC  03.0
0940:  GOTO   14E
0941:  INCF   74,F
0942:  MOVF   6E,W
0943:  IORLW  80
0944:  ADDWF  73,F
0945:  MOVF   6F,W
0946:  ADDWF  72,F
0947:  BTFSS  03.0
0948:  GOTO   12C
0949:  INCF   73,F
094A:  BTFSS  03.2
094B:  GOTO   12C
094C:  INCF   74,F
094D:  GOTO   12C
094E:  BSF    7A.0
094F:  DECFSZ 75,F
0950:  GOTO   152
0951:  GOTO   15D
0952:  BCF    03.0
0953:  RLF    71,F
0954:  RLF    72,F
0955:  RLF    73,F
0956:  RLF    74,F
0957:  BCF    03.0
0958:  RLF    7A,F
0959:  RLF    79,F
095A:  RLF    78,F
095B:  RLF    76,F
095C:  GOTO   109
095D:  BTFSS  76.0
095E:  GOTO   165
095F:  BCF    03.0
0960:  RRF    78,F
0961:  RRF    79,F
0962:  RRF    7A,F
0963:  RRF    76,F
0964:  GOTO   168
0965:  DECF   77,F
0966:  BTFSC  03.2
0967:  GOTO   1AA
0968:  BTFSC  76.7
0969:  GOTO   191
096A:  BCF    03.0
096B:  RLF    71,F
096C:  RLF    72,F
096D:  RLF    73,F
096E:  RLF    74,F
096F:  MOVF   70,W
0970:  SUBWF  71,F
0971:  BTFSC  03.0
0972:  GOTO   17D
0973:  MOVLW  01
0974:  SUBWF  72,F
0975:  BTFSC  03.0
0976:  GOTO   17D
0977:  SUBWF  73,F
0978:  BTFSC  03.0
0979:  GOTO   17D
097A:  SUBWF  74,F
097B:  BTFSS  03.0
097C:  GOTO   1A0
097D:  MOVF   6F,W
097E:  SUBWF  72,F
097F:  BTFSC  03.0
0980:  GOTO   188
0981:  MOVLW  01
0982:  SUBWF  73,F
0983:  BTFSC  03.0
0984:  GOTO   188
0985:  SUBWF  74,F
0986:  BTFSS  03.0
0987:  GOTO   1A0
0988:  MOVF   6E,W
0989:  IORLW  80
098A:  SUBWF  73,F
098B:  BTFSC  03.0
098C:  GOTO   191
098D:  MOVLW  01
098E:  SUBWF  74,F
098F:  BTFSS  03.0
0990:  GOTO   1A0
0991:  INCF   7A,F
0992:  BTFSS  03.2
0993:  GOTO   1A0
0994:  INCF   79,F
0995:  BTFSS  03.2
0996:  GOTO   1A0
0997:  INCF   78,F
0998:  BTFSS  03.2
0999:  GOTO   1A0
099A:  INCF   77,F
099B:  BTFSC  03.2
099C:  GOTO   1AA
099D:  RRF    78,F
099E:  RRF    79,F
099F:  RRF    7A,F
09A0:  MOVF   6A,W
09A1:  MOVWF  75
09A2:  MOVF   6E,W
09A3:  XORWF  75,F
09A4:  BTFSS  75.7
09A5:  GOTO   1A8
09A6:  BSF    78.7
09A7:  GOTO   1AE
09A8:  BCF    78.7
09A9:  GOTO   1AE
09AA:  CLRF   77
09AB:  CLRF   78
09AC:  CLRF   79
09AD:  CLRF   7A
09AE:  BCF    0A.3
09AF:  BSF    0A.4
09B0:  GOTO   2AD (RETURN)
*
0A4D:  MOVLW  20
0A4E:  BTFSS  66.4
0A4F:  MOVLW  30
0A50:  MOVWF  67
0A51:  MOVF   65,W
0A52:  MOVWF  77
0A53:  BTFSS  65.7
0A54:  GOTO   25D
0A55:  COMF   77,F
0A56:  INCF   77,F
0A57:  MOVF   77,W
0A58:  MOVWF  65
0A59:  MOVLW  2D
0A5A:  MOVWF  67
0A5B:  BSF    66.7
0A5C:  BSF    66.0
0A5D:  MOVF   78,W
0A5E:  CLRF   27
0A5F:  BTFSC  0B.7
0A60:  BSF    27.7
0A61:  BCF    0B.7
0A62:  MOVF   65,W
0A63:  BSF    03.5
0A64:  MOVWF  33
0A65:  MOVLW  64
0A66:  MOVWF  34
0A67:  BCF    0A.3
0A68:  BCF    03.5
0A69:  CALL   16D
0A6A:  BSF    0A.3
0A6B:  BTFSC  27.7
0A6C:  BSF    0B.7
0A6D:  MOVF   77,W
0A6E:  MOVWF  65
0A6F:  MOVLW  30
0A70:  ADDWF  78,W
0A71:  MOVWF  68
0A72:  CLRF   27
0A73:  BTFSC  0B.7
0A74:  BSF    27.7
0A75:  BCF    0B.7
0A76:  MOVF   65,W
0A77:  BSF    03.5
0A78:  MOVWF  33
0A79:  MOVLW  0A
0A7A:  MOVWF  34
0A7B:  BCF    0A.3
0A7C:  BCF    03.5
0A7D:  CALL   16D
0A7E:  BSF    0A.3
0A7F:  BTFSC  27.7
0A80:  BSF    0B.7
0A81:  MOVLW  30
0A82:  ADDWF  77,W
0A83:  MOVWF  6A
0A84:  MOVLW  30
0A85:  ADDWF  78,W
0A86:  MOVWF  69
0A87:  MOVF   67,W
0A88:  MOVWF  77
0A89:  MOVLW  30
0A8A:  SUBWF  68,W
0A8B:  BTFSC  03.2
0A8C:  GOTO   291
0A8D:  BSF    66.1
0A8E:  BTFSC  66.7
0A8F:  BSF    66.2
0A90:  GOTO   2A5
0A91:  MOVF   67,W
0A92:  MOVWF  68
0A93:  MOVLW  20
0A94:  MOVWF  67
0A95:  MOVLW  30
0A96:  SUBWF  69,W
0A97:  BTFSC  03.2
0A98:  GOTO   29D
0A99:  BSF    66.0
0A9A:  BTFSC  66.7
0A9B:  BSF    66.1
0A9C:  GOTO   2A5
0A9D:  BTFSS  03.2
0A9E:  BSF    66.0
0A9F:  BTFSS  03.2
0AA0:  GOTO   2A5
0AA1:  MOVF   68,W
0AA2:  MOVWF  69
0AA3:  MOVLW  20
0AA4:  MOVWF  68
0AA5:  BTFSC  66.2
0AA6:  GOTO   2AC
0AA7:  BTFSC  66.1
0AA8:  GOTO   2B1
0AA9:  BTFSC  66.0
0AAA:  GOTO   2B6
0AAB:  GOTO   2BB
0AAC:  MOVF   67,W
0AAD:  MOVWF  72
0AAE:  BCF    0A.3
0AAF:  CALL   702
0AB0:  BSF    0A.3
0AB1:  MOVF   68,W
0AB2:  MOVWF  72
0AB3:  BCF    0A.3
0AB4:  CALL   702
0AB5:  BSF    0A.3
0AB6:  MOVF   69,W
0AB7:  MOVWF  72
0AB8:  BCF    0A.3
0AB9:  CALL   702
0ABA:  BSF    0A.3
0ABB:  MOVF   6A,W
0ABC:  MOVWF  72
0ABD:  BCF    0A.3
0ABE:  CALL   702
0ABF:  BSF    0A.3
0AC0:  RETURN
0AC1:  MOVF   0B,W
0AC2:  MOVWF  66
0AC3:  BCF    0B.7
0AC4:  BSF    03.5
0AC5:  BSF    03.6
0AC6:  BSF    0C.7
0AC7:  BSF    0C.0
0AC8:  NOP
0AC9:  NOP
0ACA:  BTFSC  03.0
0ACB:  GOTO   2F5
0ACC:  BCF    03.5
0ACD:  MOVF   0C,W
0ACE:  ANDLW  7F
0ACF:  BCF    03.6
0AD0:  MOVWF  67
0AD1:  BSF    03.6
0AD2:  MOVF   0D,W
0AD3:  BCF    03.6
0AD4:  MOVWF  68
0AD5:  BSF    03.6
0AD6:  MOVF   0F,W
0AD7:  BCF    03.6
0AD8:  MOVWF  69
0AD9:  MOVF   67,W
0ADA:  MOVWF  72
0ADB:  BCF    0A.3
0ADC:  CALL   702
0ADD:  BSF    0A.3
0ADE:  MOVF   68,W
0ADF:  BSF    03.6
0AE0:  MOVWF  0D
0AE1:  BCF    03.6
0AE2:  MOVF   69,W
0AE3:  BSF    03.6
0AE4:  MOVWF  0F
0AE5:  BSF    03.5
0AE6:  BSF    0C.7
0AE7:  BSF    0C.0
0AE8:  NOP
0AE9:  NOP
0AEA:  BCF    03.5
0AEB:  BCF    03.6
0AEC:  DECFSZ 65,F
0AED:  GOTO   2EF
0AEE:  GOTO   2F2
0AEF:  BSF    03.5
0AF0:  BSF    03.6
0AF1:  GOTO   2F5
0AF2:  GOTO   316
0AF3:  BSF    03.5
0AF4:  BSF    03.6
0AF5:  BCF    03.5
0AF6:  RLF    0C,W
0AF7:  RLF    0E,W
0AF8:  ANDLW  7F
0AF9:  BCF    03.6
0AFA:  MOVWF  67
0AFB:  BSF    03.6
0AFC:  MOVF   0D,W
0AFD:  BCF    03.6
0AFE:  MOVWF  68
0AFF:  BSF    03.6
0B00:  MOVF   0F,W
0B01:  BCF    03.6
0B02:  MOVWF  69
0B03:  MOVF   67,W
0B04:  MOVWF  72
0B05:  BCF    0A.3
0B06:  CALL   702
0B07:  BSF    0A.3
0B08:  MOVF   68,W
0B09:  BSF    03.6
0B0A:  MOVWF  0D
0B0B:  BCF    03.6
0B0C:  MOVF   69,W
0B0D:  BSF    03.6
0B0E:  MOVWF  0F
0B0F:  INCF   0D,F
0B10:  BTFSC  03.2
0B11:  INCF   0F,F
0B12:  BCF    03.0
0B13:  BCF    03.6
0B14:  DECFSZ 65,F
0B15:  GOTO   2C4
0B16:  BTFSC  66.7
0B17:  BSF    0B.7
0B18:  RETURN
0B19:  MOVF   04,W
0B1A:  MOVWF  6A
0B1B:  MOVF   69,W
0B1C:  MOVWF  6C
0B1D:  BTFSC  03.2
0B1E:  GOTO   348
0B1F:  CLRF   27
0B20:  BTFSC  0B.7
0B21:  BSF    27.7
0B22:  BCF    0B.7
0B23:  MOVF   68,W
0B24:  BSF    03.5
0B25:  MOVWF  3D
0B26:  BCF    03.5
0B27:  MOVF   67,W
0B28:  BSF    03.5
0B29:  MOVWF  3C
0B2A:  BCF    03.5
0B2B:  MOVF   66,W
0B2C:  BSF    03.5
0B2D:  MOVWF  3B
0B2E:  BCF    03.5
0B2F:  MOVF   65,W
0B30:  BSF    03.5
0B31:  MOVWF  3A
0B32:  CLRF   41
0B33:  CLRF   40
0B34:  MOVLW  20
0B35:  MOVWF  3F
0B36:  MOVLW  82
0B37:  MOVWF  3E
0B38:  BCF    0A.3
0B39:  BCF    03.5
0B3A:  CALL   253
0B3B:  BSF    0A.3
0B3C:  BTFSC  27.7
0B3D:  BSF    0B.7
0B3E:  MOVF   7A,W
0B3F:  MOVWF  68
0B40:  MOVF   79,W
0B41:  MOVWF  67
0B42:  MOVF   78,W
0B43:  MOVWF  66
0B44:  MOVF   77,W
0B45:  MOVWF  65
0B46:  DECFSZ 6C,F
0B47:  GOTO   31F
0B48:  CLRF   27
0B49:  BTFSC  0B.7
0B4A:  BSF    27.7
0B4B:  BCF    0B.7
0B4C:  MOVF   68,W
0B4D:  BSF    03.5
0B4E:  MOVWF  3D
0B4F:  BCF    03.5
0B50:  MOVF   67,W
0B51:  BSF    03.5
0B52:  MOVWF  3C
0B53:  BCF    03.5
0B54:  MOVF   66,W
0B55:  BSF    03.5
0B56:  MOVWF  3B
0B57:  BCF    03.5
0B58:  MOVF   65,W
0B59:  BSF    03.5
0B5A:  MOVWF  3A
0B5B:  BCF    0A.3
0B5C:  BCF    03.5
0B5D:  CALL   2CA
0B5E:  BSF    0A.3
0B5F:  BTFSC  27.7
0B60:  BSF    0B.7
0B61:  MOVF   7A,W
0B62:  MOVWF  68
0B63:  MOVF   79,W
0B64:  MOVWF  67
0B65:  MOVF   78,W
0B66:  MOVWF  66
0B67:  MOVF   77,W
0B68:  MOVWF  65
0B69:  BTFSS  68.7
0B6A:  GOTO   378
0B6B:  DECF   6A,F
0B6C:  BSF    6A.5
0B6D:  COMF   65,F
0B6E:  COMF   66,F
0B6F:  COMF   67,F
0B70:  COMF   68,F
0B71:  INCF   65,F
0B72:  BTFSC  03.2
0B73:  INCF   66,F
0B74:  BTFSC  03.2
0B75:  INCF   67,F
0B76:  BTFSC  03.2
0B77:  INCF   68,F
0B78:  MOVLW  3B
0B79:  MOVWF  71
0B7A:  MOVLW  9A
0B7B:  MOVWF  70
0B7C:  MOVLW  CA
0B7D:  MOVWF  6F
0B7E:  CLRF   6E
0B7F:  MOVLW  0A
0B80:  MOVWF  6C
0B81:  MOVF   69,W
0B82:  BTFSC  03.2
0B83:  INCF   6A,F
0B84:  BSF    03.1
0B85:  MOVLW  65
0B86:  MOVWF  04
0B87:  BCF    03.7
0B88:  CLRF   27
0B89:  BTFSC  0B.7
0B8A:  BSF    27.7
0B8B:  BCF    0B.7
0B8C:  MOVF   68,W
0B8D:  BSF    03.5
0B8E:  MOVWF  3D
0B8F:  BCF    03.5
0B90:  MOVF   67,W
0B91:  BSF    03.5
0B92:  MOVWF  3C
0B93:  BCF    03.5
0B94:  MOVF   66,W
0B95:  BSF    03.5
0B96:  MOVWF  3B
0B97:  BCF    03.5
0B98:  MOVF   65,W
0B99:  BSF    03.5
0B9A:  MOVWF  3A
0B9B:  MOVF   71,W
0B9C:  MOVWF  41
0B9D:  MOVF   70,W
0B9E:  MOVWF  40
0B9F:  BCF    03.5
0BA0:  MOVF   6F,W
0BA1:  BSF    03.5
0BA2:  MOVWF  3F
0BA3:  BCF    03.5
0BA4:  MOVF   6E,W
0BA5:  BSF    03.5
0BA6:  MOVWF  3E
0BA7:  BCF    0A.3
0BA8:  BCF    03.5
0BA9:  CALL   2EB
0BAA:  BSF    0A.3
0BAB:  BTFSC  27.7
0BAC:  BSF    0B.7
0BAD:  MOVF   78,W
0BAE:  MOVF   77,F
0BAF:  BTFSS  03.2
0BB0:  GOTO   3C4
0BB1:  INCF   69,W
0BB2:  SUBWF  6C,W
0BB3:  BTFSC  03.2
0BB4:  GOTO   3C4
0BB5:  MOVF   6A,W
0BB6:  BTFSC  03.2
0BB7:  GOTO   3C6
0BB8:  ANDLW  0F
0BB9:  SUBWF  6C,W
0BBA:  BTFSC  03.2
0BBB:  GOTO   3BE
0BBC:  BTFSC  03.0
0BBD:  GOTO   3FE
0BBE:  BTFSC  6A.7
0BBF:  GOTO   3FE
0BC0:  BTFSC  6A.6
0BC1:  GOTO   3C6
0BC2:  MOVLW  20
0BC3:  GOTO   3F8
0BC4:  MOVLW  20
0BC5:  ANDWF  6A,F
0BC6:  BTFSS  6A.5
0BC7:  GOTO   3D6
0BC8:  BCF    6A.5
0BC9:  MOVF   69,W
0BCA:  BTFSS  03.2
0BCB:  DECF   6A,F
0BCC:  MOVF   77,W
0BCD:  MOVWF  6A
0BCE:  MOVLW  2D
0BCF:  MOVWF  72
0BD0:  BCF    0A.3
0BD1:  CALL   702
0BD2:  BSF    0A.3
0BD3:  MOVF   6A,W
0BD4:  MOVWF  77
0BD5:  CLRF   6A
0BD6:  MOVF   69,W
0BD7:  SUBWF  6C,W
0BD8:  BTFSS  03.2
0BD9:  GOTO   3E6
0BDA:  MOVF   77,W
0BDB:  MOVWF  6A
0BDC:  MOVLW  2E
0BDD:  MOVWF  72
0BDE:  BCF    0A.3
0BDF:  CALL   702
0BE0:  BSF    0A.3
0BE1:  MOVF   6A,W
0BE2:  MOVWF  77
0BE3:  MOVLW  20
0BE4:  ANDWF  6A,F
0BE5:  MOVLW  00
0BE6:  MOVLW  30
0BE7:  BTFSS  6A.5
0BE8:  GOTO   3F8
0BE9:  BCF    6A.5
0BEA:  MOVF   69,W
0BEB:  BTFSS  03.2
0BEC:  DECF   6A,F
0BED:  MOVF   77,W
0BEE:  MOVWF  6A
0BEF:  MOVLW  2D
0BF0:  MOVWF  72
0BF1:  BCF    0A.3
0BF2:  CALL   702
0BF3:  BSF    0A.3
0BF4:  MOVF   6A,W
0BF5:  MOVWF  77
0BF6:  CLRF   6A
0BF7:  MOVLW  30
0BF8:  ADDWF  77,F
0BF9:  MOVF   77,W
0BFA:  MOVWF  72
0BFB:  BCF    0A.3
0BFC:  CALL   702
0BFD:  BSF    0A.3
0BFE:  BCF    03.1
0BFF:  CLRF   27
0C00:  BTFSC  0B.7
0C01:  BSF    27.7
0C02:  BCF    0B.7
0C03:  MOVF   71,W
0C04:  BSF    03.5
0C05:  MOVWF  3D
0C06:  MOVF   70,W
0C07:  MOVWF  3C
0C08:  BCF    03.5
0C09:  MOVF   6F,W
0C0A:  BSF    03.5
0C0B:  MOVWF  3B
0C0C:  BCF    03.5
0C0D:  MOVF   6E,W
0C0E:  BSF    03.5
0C0F:  MOVWF  3A
0C10:  CLRF   41
0C11:  CLRF   40
0C12:  CLRF   3F
0C13:  MOVLW  0A
0C14:  MOVWF  3E
0C15:  BCF    0A.3
0C16:  BCF    03.5
0C17:  CALL   2EB
0C18:  BSF    0A.3
0C19:  BTFSC  27.7
0C1A:  BSF    0B.7
0C1B:  MOVF   7A,W
0C1C:  MOVWF  71
0C1D:  MOVF   79,W
0C1E:  MOVWF  70
0C1F:  MOVF   78,W
0C20:  MOVWF  6F
0C21:  MOVF   77,W
0C22:  MOVWF  6E
0C23:  DECFSZ 6C,F
0C24:  GOTO   384
0C25:  BCF    0A.3
0C26:  BSF    0A.4
0C27:  GOTO   5CA (RETURN)
0C28:  MOVF   00,F
0C29:  BTFSC  03.2
0C2A:  GOTO   43F
0C2B:  CLRF   66
0C2C:  MOVF   04,W
0C2D:  MOVWF  65
0C2E:  BCF    66.0
0C2F:  BTFSC  03.7
0C30:  BSF    66.0
0C31:  MOVF   00,W
0C32:  MOVWF  72
0C33:  BCF    0A.3
0C34:  CALL   702
0C35:  BSF    0A.3
0C36:  MOVF   65,W
0C37:  MOVWF  04
0C38:  BCF    03.7
0C39:  BTFSC  66.0
0C3A:  BSF    03.7
0C3B:  INCF   04,F
0C3C:  BTFSC  03.2
0C3D:  INCF   05,F
0C3E:  GOTO   428
0C3F:  RETURN
....................  
.................... #list 
....................  
.................... //#fuses XT,NOWDT,NOPROTECT,NOBROWNOUT,NOLVP,NOPUT,NOWRT,NOCPD 
.................... #fuses HS,NOWDT,NOPROTECT,NOLVP  
.................... #device ADC = 10 
....................  
.................... #include "add_lcd.h" 
.................... #define _lcd_h_ 
.................... #include <math.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2011 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////                                                                    //// 
.................... //// History:                                                           //// 
.................... ////  * 9/20/2001 :  Improvments are made to sin/cos code.              //// 
.................... ////                 The code now is small, much faster,                //// 
.................... ////                 and more accurate.                                 //// 
.................... ////  * 2/21/2007 :  Compiler handles & operator differently and does   //// 
.................... ////                 not return generic (int8 *) so type cast is done   //// 
.................... ////  * 6/19/2010 :  Divisions by constants converted to multiplication //// 
.................... ////                 by its inverse to improve computation speed        //// 
.................... ////  * 1/21/2011 :  Constants used for double precision math updated   //// 
.................... ////                 Updated routines include 64 bit versions of cos,   //// 
.................... ////                 asin,atan,exp,log and dependant functions          //// 
.................... ////  * 1/31/2011 :  Optimized current 32-bit float routines for cos    //// 
.................... ////                 and log function                                   //// 
.................... ////  * 6/13/2011 :  Fixed PCD overload CEIL_FLOOR functions for values //// 
.................... ////                 greater then 10000000 and less then -10000000      //// 
.................... ////                                                                    //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef MATH_H 
.................... #define MATH_H 
....................  
.................... #ifdef PI 
.................... #undef  PI 
.................... #endif 
.................... #define PI     3.1415926535897932 
....................  
....................  
.................... #define SQRT2  1.4142135623730950 
....................  
.................... //float const ps[4] = {5.9304945, 21.125224, 8.9403076, 0.29730279}; 
.................... //float const qs[4] = {1.0000000, 15.035723, 17.764134, 2.4934718}; 
....................  
.................... ///////////////////////////// Round Functions ////////////////////////////// 
....................  
.................... float32 CEIL_FLOOR(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res; 
....................    unsigned int16 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float32)(unsigned int16)y; 
....................  
....................  else if (y < 10000000.0) 
....................    {  
....................       l = (unsigned int16)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float32)l); 
....................       res = 32768.0*(float32)l; 
....................       res += (float32)(unsigned int16)y; 
....................    } 
....................  
....................  else 
....................   res = y; 
....................  
....................  y = y - (float32)(unsigned int16)y; 
....................  
....................  if (s) 
....................   res = -res; 
....................  
....................  if (y != 0) 
....................  { 
....................   if (s == 1 && n == 0) 
....................    res -= 1.0; 
....................  
....................   if (s == 0 && n == 1) 
....................    res += 1.0; 
....................  } 
....................  if (x == 0) 
....................     res = 0; 
....................  
....................  return (res); 
.................... } 
....................  
.................... // Overloaded Functions to take care for new Data types in PCD 
.................... // Overloaded function CEIL_FLOOR() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 CEIL_FLOOR(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res; 
....................    unsigned int32 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float48)(unsigned int16)y; 
....................  
....................    else if (y < 549755813888.0) 
....................    { 
....................       l = (unsigned int32)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float48)l); 
....................       res = 32768.0*(float48)l; 
....................       res += (float48)(unsigned int16)y; 
....................    } 
....................    else 
....................    {   
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float48)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
....................  
....................  
.................... // Overloaded function CEIL_FLOOR() for data type - Float64 
.................... float64 CEIL_FLOOR(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res; 
....................    int64 l; 
....................    int1 s; 
....................  
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y <= 32768.0) 
....................       res = (float64)(unsigned int16)y; 
....................    else if (y < 4503599627370496.0) 
....................    { 
....................       l = (int64)(y*0.000030517578125); 
....................       y = 32768.0*(y*0.000030517578125 - (float64)l); 
....................       res = 32768.0*(float64)l; 
....................       res += (float64)(unsigned int16)y; 
....................    } 
....................    else 
....................    { 
....................       res = y; 
....................       y = 0.0; 
....................    } 
....................     
....................    if(y != 0) 
....................       y = y - (float64)(unsigned int16)y; 
....................  
....................    if (s) 
....................       res = -res; 
....................  
....................    if (y != 0) 
....................    { 
....................       if (s == 1 && n == 0) 
....................          res -= 1.0; 
....................  
....................       if (s == 0 && n == 1) 
....................          res += 1.0; 
....................    } 
....................     
....................    if (x == 0) 
....................       res = 0; 
....................  
....................    return (res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float floor(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds down the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 floor(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x,0); 
.................... } 
.................... // Following 2 functions are overloaded functions of floor() for PCD 
.................... // Overloaded function floor() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 floor(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
....................  
.................... // Overloaded function floor() for data type - Float64 
.................... float64 floor(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 0); 
.................... } 
.................... #endif 
....................  
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float ceil(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : rounds up the number x. 
.................... // Date : N/A 
.................... // 
.................... float32 ceil(float32 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... // Following 2 functions are overloaded functions of ceil() for PCD 
.................... // Overloaded function ceil() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ceil(float48 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
....................  
.................... // Overloaded function ceil() for data type - Float64 
.................... float64 ceil(float64 x) 
.................... { 
....................    return CEIL_FLOOR(x, 1); 
.................... } 
.................... #endif 
....................  
....................  //////////////////////////////////////////////////////////////////////////// 
.................... //   float fabs(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the absolute value of floating point number x 
.................... // Returns : returns the absolute value of x 
.................... // Date : N/A 
.................... // 
.................... #define fabs abs 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float fmod(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the floating point remainder of x/y 
.................... // Returns : returns the value of x= i*y, for some integer i such that, if y 
.................... // is non zero, the result has the same isgn of x na dmagnitude less than the 
.................... // magnitude of y. If y is zero then a domain error occurs. 
.................... // Date : N/A 
.................... // 
....................  
.................... float fmod(float32 x,float32 y) 
.................... { 
....................    float32 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... //Overloaded function for fmod() for PCD 
.................... // Overloaded function fmod() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 fmod(float48 x,float48 y) 
.................... { 
....................    float48 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... // Overloaded function fmod() for data type - Float64 
.................... float64 fmod(float64 x,float64 y) 
.................... { 
....................    float64 i; 
....................    if (y!=0.0) 
....................    { 
....................       i=(x/y < 0.0)? ceil(x/y): floor(x/y); 
....................       return(x-(i*y)); 
....................    } 
....................    else 
....................    { 
....................    #ifdef _ERRNO 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    } 
.................... } 
.................... #endif 
.................... //////////////////// Exponential and logarithmic functions //////////////////// 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float exp(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (e^x) 
.................... // Date : N/A 
.................... // 
.................... #define LN2 0.6931471805599453 
.................... #define LN2_INV 1.4426950408889634073 
....................  
.................... float const pe[6] = {0.000207455774, 0.00127100575, 0.00965065093, 
....................                      0.0554965651,  0.240227138,  0.693147172}; 
....................  
....................  
.................... float32 exp(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    #if defined(__PCD__) 
....................    int8 data1; 
....................    #endif 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
.................... #if !defined(__PCD__) 
....................    *((unsigned int8 *)(&res)) = n + 0x7F; 
.................... #endif 
....................  
.................... #if defined(__PCD__)  // Takes care of IEEE format for PCD 
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+2)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+3)) = data1; 
.................... #endif 
....................  
....................    y = y*LN2_INV - (float32)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded function for exp() for PCD 
.................... // Overloaded function exp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 exp(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int8 data1; 
....................    signed int8 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 88.722838) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    n = (signed int16)(x*LN2_INV); 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
....................    data1 = n+0x7F; 
....................    if(bit_test(data1,0)) 
....................    bit_set(*(((unsigned int8 *)(&res)+4)),7); 
....................    rotate_right(&data1,1); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&res)+5)) = data1; 
....................  
....................    y = y*LN2_INV - (float48)n; 
....................  
....................    r = pe[0]*y + pe[1]; 
....................    r = r*y + pe[2]; 
....................    r = r*y + pe[3]; 
....................    r = r*y + pe[4]; 
....................    r = r*y + pe[5]; 
....................  
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function exp() for data type - Float64 
.................... float64 const pe_64[12] ={9.30741400474913e-011,-4.28655416283316e-011, 
....................                           8.71486547014137e-009,9.84458531538385e-008, 
....................                           1.32588296983536e-006,1.52489283823016e-005, 
....................                           0.000154037598423921,0.00133335487036216, 
....................                           0.00961812936407326,0.0555041086222122, 
....................                           0.240226506962827,0.693147180559823}; 
....................  
.................... float64 exp(float64 x) 
.................... { 
....................    float64 y, res, r; 
....................    unsigned int16 data1, data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x > 709.7827128) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x*LN2_INV; 
....................    n = (signed int16)y; 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       n = -n; 
....................       y = -y; 
....................    } 
....................  
....................    res = 0.0; 
....................  
.................... #if !defined(__PCD__) 
....................    *((unsigned int16 *)(&res)) = n + 0x7F; 
.................... #endif 
....................    p= (((unsigned int16 *)(&res))+3); 
....................    data1 = *p; 
....................    data2 = *p;    
....................    data1 = n + 0x3FF; 
....................    data1 = data1 <<4; 
....................    if(bit_test(data2,15)) 
....................    bit_set(data1,15); 
....................    data2 = data2 & 0x000F; 
....................    data1 ^= data2; 
....................  
....................    *(((unsigned int16 *)(&res)+3)) = data1; 
....................  
....................  
....................    y = y*LN2_INV - (float64)n; 
....................  
....................    r = pe_64[0]*y + pe_64[1]; 
....................    r = r*y + pe_64[2]; 
....................    r = r*y + pe_64[3]; 
....................    r = r*y + pe_64[4]; 
....................    r = r*y + pe_64[5]; 
....................    r = r*y + pe_64[6]; 
....................    r = r*y + pe_64[7]; 
....................    r = r*y + pe_64[8]; 
....................    r = r*y + pe_64[9]; 
....................    r = r*y + pe_64[10]; 
....................    r = r*y + pe_64[11]; 
....................     
....................    res = res*(1.0 + y*r); 
....................  
....................    if (s) 
....................       res = 1.0/res; 
....................    return(res); 
.................... } 
.................... #ENDIF 
....................  
....................  
.................... /************************************************************/ 
....................  
.................... float32 const pl[4] = {-1.080310025160955, 1.999999947089217}; 
.................... float32 const ql[4] = {0.091284365719509, -0.873491916557671}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the natural log of x 
.................... // Date : N/A 
.................... // 
.................... float32 log(float32 x) 
.................... { 
....................    float32 y, res, r, y2; 
....................    #if defined(__PCD__) 
....................    unsigned int8  data1,data2; 
....................    #endif 
....................    signed int8 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
.................... #if !defined(__PCD__) 
....................     *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................  
.................... #if defined(__PCD__) // Takes care of IEEE format 
....................    data2 = *(((unsigned int8 *)(&y))+3); 
....................    *(((unsigned int8 *)(&y))+3) = 0x3F; 
....................    data1 = *(((unsigned int8 *)(&y))+2); 
....................    bit_clear(data1,7); 
....................    *(((unsigned int8 *)(&y))+2) = data1; 
....................    if(bit_test(data2,7)) 
....................      bit_set(*(((unsigned int8 *)(&y))+3),7); 
.................... #endif 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl[0]*y2 + pl[1]; 
....................  
....................       r = ql[0]*y2 + ql[1]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
.................... #if !defined(__PCD__) 
....................       n = *((unsigned int8 *)(&x)) - 0x7E; 
.................... #endif 
.................... #if defined(__PCD__)  
....................     data1 = *(((unsigned int8 *)(&x)+3)); 
....................     rotate_left(&data1,1); 
....................     data2 = *(((unsigned int8 *)(&x)+2)); 
....................     if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................     n = data1 - 0x7E; 
.................... #endif 
....................  
....................       if (n<0)  
....................          r = -(float32)-n; 
....................       else 
....................          r = (float32)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... //Overloaded function for log() for PCD 
.................... // Overloaded function log() for data type - Float48 
.................... #if defined(__PCD__) 
.................... // Overloaded function log() for data type - float64 
.................... float64 const pl_64[4] = {-0.145694052150681, 1.365485300000370, 
....................                           -3.120535668274329, 2.000000000000000}; 
....................  
.................... float64 const ql_64[4] = {0.006047500465908, -0.208298281937234, 
....................                           1.113943039156721, -1.893601167470470}; 
....................  
.................... float48 log(float48 x) 
.................... { 
....................    float48 y, res, r, y2; 
....................    unsigned int8  data1,data2; 
....................    signed int8 n; 
.................... #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
.................... #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................  
.................... #if !defined(__PCD__) 
....................       *((unsigned int8 *)(&y)) = 0x7E;  
.................... #endif 
....................       data2 = *(((unsigned int8 *)(&y))+5); 
....................       *(((unsigned int8 *)(&y))+5) = 0x3F; 
....................       data1 = *(((unsigned int8 *)(&y))+4); 
....................       bit_clear(data1,7); 
....................       *(((unsigned int8 *)(&y))+4) = data1; 
....................  
....................       if(bit_test(data2,7)) 
....................       bit_set(*(((unsigned int8 *)(&y))+4),7); 
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0;  
....................       res = y*res/r; 
....................  
....................       data1 = *(((unsigned int8 *)(&x)+5)); 
....................       rotate_left(&data1,1); 
....................       data2 = *(((unsigned int8 *)(&x)+4)); 
....................       if(bit_test (data2,7)) 
....................       bit_set(data1,0); 
....................        
....................       n = data1 - 0x7E; 
....................  
....................       if (n<0) 
....................       r = -(float48)-n; 
....................       else 
....................       r = (float48)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................    res = 0.0; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 log(float64 x) 
.................... { 
....................    float64 y, res, r, y2; 
....................    unsigned int16  data1,data2; 
....................    unsigned int16 *p; 
....................    signed int16 n; 
....................    #ifdef _ERRNO 
....................    if(x <0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    if(x ==0) 
....................    { 
....................       errno=ERANGE; 
....................       return(0); 
....................    } 
....................    #endif 
....................    y = x; 
....................  
....................    if (y != 1.0) 
....................    { 
....................    #if !defined(__PCD__) 
....................        *((unsigned int8 *)(&y)) = 0x7E;  
....................    #endif 
....................       p= (((unsigned int16 *)(&y))+3); 
....................       data1 = *p; 
....................       data2 = *p; 
....................       data1 = 0x3FE; 
....................       data1 = data1 <<4; 
....................       if(bit_test (data2,15)) 
....................          bit_set(data1,15); 
....................       data2 = data2 & 0x000F; 
....................       data1 ^=data2; 
....................  
....................       *p = data1; 
....................  
....................       y = (y - 1.0)/(y + 1.0); 
....................  
....................       y2=y*y; 
....................  
....................       res = pl_64[0]*y2 + pl_64[1]; 
....................       res = res*y2 + pl_64[2]; 
....................       res = res*y2 + pl_64[3]; 
....................  
....................       r = ql_64[0]*y2 + ql_64[1]; 
....................       r = r*y2 + ql_64[2]; 
....................       r = r*y2 + ql_64[3]; 
....................       r = r*y2 + 1.0; 
....................  
....................       res = y*res/r; 
....................   
....................       p= (((unsigned int16 *)(&x))+3); 
....................       data1 = *p; 
....................       bit_clear(data1,15); 
....................       data1 = data1 >>4;     
....................       n = data1 - 0x3FE; 
....................  
....................  
....................       if (n<0) 
....................          r = -(float64)-n; 
....................       else 
....................          r = (float64)n; 
....................  
....................       res += r*LN2; 
....................    } 
....................  
....................    else 
....................       res = 0.0; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
....................  
.................... #define LN10 2.3025850929940456 
.................... #define LN10_INV 0.4342944819032518276 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float log10(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the the log base 10 of x 
.................... // Date : N/A 
.................... // 
.................... float32 log10(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... //Overloaded functions for log10() for PCD 
.................... // Overloaded function log10() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 log10(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function log10() for data type - Float64 
.................... float64 log10(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = log(x); 
....................    r = r*LN10_INV; 
....................    return(r); 
.................... } 
.................... #endif 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float modf(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description :breaks the argument value int integral and fractional parts, 
.................... // ach of which have the same sign as the argument.  It stores the integral part 
.................... // as a float in the object pointed to by the iptr 
.................... // Returns : returns the signed fractional part of value. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 modf(float32 value,float32 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... //Overloaded functions for modf() for PCD 
.................... // Overloaded function modf() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 modf(float48 value,float48 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... // Overloaded function modf() for data type - Float64 
.................... float64 modf(float64 value,float64 *iptr) 
.................... { 
....................    *iptr=(value < 0.0)? ceil(value): floor(value); 
....................    return(value - *iptr); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pwr(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pwr(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pwr() for PCD 
.................... // Overloaded function pwr() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pwr(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... // Overloaded function pwr() for data type - Float64 
.................... float64 pwr(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Power functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float pow(float x,float y) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the value (x^y) 
.................... // Date : N/A 
.................... // Note : 0 is returned when the function will generate an imaginary number 
.................... // 
.................... float32 pow(float32 x,float32 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... //Overloaded functions for pow() for PCD 
.................... // Overloaded function for pow() data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 pow(float48 x,float48 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function pow() for data type - Float64 
.................... float64 pow(float64 x,float64 y) 
.................... { 
....................    if(0 > x && fmod(y, 1) == 0) { 
....................       if(fmod(y, 2) == 0) { 
....................          return (exp(log(-x) * y)); 
....................       } else { 
....................          return (-exp(log(-x) * y)); 
....................       } 
....................    } else if(0 > x && fmod(y, 1) != 0) { 
....................       return 0; 
....................    } else { 
....................       if(x != 0 || 0 >= y) { 
....................          return (exp(log(x) * y)); 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sqrt(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the square root of x 
.................... // Date : N/A 
.................... // 
.................... float32 sqrt(float32 x) 
.................... { 
....................    float32 y, res; 
....................    #if defined(__PCD__) 
....................    unsigned int16 data1,data2; 
....................    #endif 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+3); 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1);     
....................     if(bit_test(data2,7))     
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     data1 = *(((unsigned int8 *)(&y))+3); 
....................     data2 = *(((unsigned int8 *)(&y))+2); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+3) = data1; 
....................     *(((unsigned int8 *)(&y))+2) = data2; 
....................      
....................   #endif 
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for sqrt() for PCD 
.................... // Overloaded function sqrt() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sqrt(float48 x) 
.................... { 
....................    float48 y, res; 
....................    unsigned int16 data1,data2; 
....................    unsigned int8 *p; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................     
....................    #if !defined(__PCD__) 
....................     p=&y; 
....................    (*p)=(unsigned int8)((((unsigned int16)(*p)) + 127) >> 1); 
....................    #endif 
....................     
....................    #if defined(__PCD__) 
....................     p = (((unsigned int8 *)(&y))+5); 
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1 = ((data1+127) >>1); 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................   #endif 
....................  
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................  
....................       #if !defined(__PCD__) 
....................      (*p)--; 
....................    #endif 
....................     
....................     data1 = *(((unsigned int8 *)(&y))+5); 
....................     data2 = *(((unsigned int8 *)(&y))+4); 
....................     rotate_left(&data1,1); 
....................     if(bit_test(data2,7)) 
....................        bit_set(data1,0);     
....................     data1--; 
....................     bit_clear(data2,7); 
....................     if(bit_test(data1,0)) 
....................        bit_set(data2,7); 
....................     data1 = data1 >>1; 
....................     *(((unsigned int8 *)(&y))+5) = data1; 
....................     *(((unsigned int8 *)(&y))+4) = data2; 
....................      
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function sqrt() for data type - Float64 
.................... float64 sqrt(float64 x) 
.................... { 
....................    float64 y, res; 
....................    unsigned int16 *p; 
....................    unsigned int16 temp1,temp2; 
....................  
....................    #ifdef _ERRNO 
....................    if(x < 0) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................  
....................    if( x<=0.0) 
....................       return(0.0); 
....................  
....................    y=x; 
....................    p= (((unsigned int16 *)(&y))+3); 
....................    temp1 = *p; 
....................    temp2 = *p; 
....................    bit_clear(temp1,15); 
....................    temp1 = (temp1>>4)+1023; 
....................    temp1 = temp1 >> 1; 
....................    temp1 = (temp1<<4) & 0xFFF0; 
....................    if(bit_test(temp2,15)) 
....................       bit_set(temp1,15); 
....................    temp2 = temp2 & 0x000F; 
....................    temp1 ^= temp2; 
....................     
....................    (*p) = temp1; 
....................     
....................    do { 
....................       res=y; 
....................       y+=(x/y); 
....................      temp1 = *p; 
....................      temp2 = *p; 
....................      bit_clear(temp1,15); 
....................      temp1 = (temp1>>4); 
....................      temp1--; 
....................      temp1 = (temp1<<4) & 0xFFF0; 
....................      if(bit_test(temp2,15)) 
....................         bit_set(temp1,15); 
....................      temp2 = temp2 & 0x000F; 
....................      temp1 ^= temp2; 
....................      (*p) = temp1; 
....................  
....................    } while(res != y); 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////// Trig Functions ////////////////////////////// 
.................... #ifdef PI_DIV_BY_TWO_INV 
.................... #undef PI_DIV_BY_TWO_INV 
.................... #endif 
.................... #define PI_DIV_BY_TWO_INV 0.63661977236758134 
.................... #ifdef PI_DIV_BY_TWO 
.................... #undef PI_DIV_BY_TWO 
.................... #endif 
.................... #define PI_DIV_BY_TWO   1.5707963267948966 
.................... #ifdef TWOBYPI 
.................... #undef TWOBYPI 
.................... #endif 
.................... #define TWOBYPI          0.6366197723675813 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the cosine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 cos(float32 x) 
.................... { 
....................    float32 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float32 frac; 
....................    float32 p[5] = {                    //by the series definition for cosine 
....................       -0.49999999456337096,            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166663896921267, 
....................       -0.00138883894522527, 
....................        0.00002476138231734, 
....................       -0.00000026070414770 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 4; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
....................  
.................... //Overloaded functions for cos() for PCD 
.................... // Overloaded function cos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cos(float48 x) 
.................... { 
....................    float48 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float48 frac; 
....................    float48 p[6] = {                    //by the series definition for cosine 
....................       -0.5,                            // sum ( ( (-1)^n * x^2n )/(2n)! ) 
....................        0.04166666666667, 
....................       -0.00138888888889, 
....................        0.00002480158730, 
....................       -0.00000027557319, 
....................        0.00000000208767, 
....................       //-0.00000000001147, 
....................       // 0.00000000000005 
....................    }; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 0.999999999781; 
....................    t = t * t; 
....................    for (i = 0; i <= 5; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... // Overloaded function cos() for data type - Float64 
.................... float64 cos(float64 x) 
.................... { 
....................    float64 y, t, t2 = 1.0; 
....................    unsigned int8 quad, i; 
....................    float64 frac; 
....................    float64 p_64[9] = {               //by the series definition for cosine 
....................      -0.49999999999998740,           // sum ( ( (-1)^n * x^2n )/(2n)! )              
....................       0.04166666666656518, 
....................      -0.00138888888851691, 
....................       0.00002480158658490, 
....................      -0.00000027557239796, 
....................       0.00000000208715031, 
....................      -0.00000000001126577, 
....................       0.00000000000000427, 
....................       0.00000000000000372}; 
....................  
....................    if (x < 0) x = -x;                  // absolute value of input 
....................  
....................    quad = (unsigned int8)(x * PI_DIV_BY_TWO_INV);    // quadrant 
....................    frac = (x * PI_DIV_BY_TWO_INV) - quad;  // fractional part of input 
....................    quad = quad % 4;                    // quadrant (0 to 3) 
....................  
....................    if (quad == 0 || quad == 2) 
....................       t = frac * PI_DIV_BY_TWO; 
....................    else if (quad == 1) 
....................       t = (1-frac) * PI_DIV_BY_TWO; 
....................    else // should be 3 
....................       t = (frac-1) * PI_DIV_BY_TWO; 
....................  
....................    y = 1.0; 
....................    t = t * t; 
....................    for (i = 0; i <= 8; i++) 
....................    { 
....................       t2 = t2 * t; 
....................       y = y + p_64[i] * t2; 
....................    } 
....................  
....................    if (quad == 2 || quad == 1) 
....................       y = -y;  // correct sign 
....................  
....................    return (y); 
.................... } 
....................  
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the sine value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 sin(float32 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... //Overloaded functions for sin() for PCD 
.................... // Overloaded function sin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sin(float48 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
....................  
.................... // Overloaded function sin() for data type - Float48 
.................... float64 sin(float64 x) 
.................... { 
....................    return cos(x - PI_DIV_BY_TWO); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the tangent value of the angle x, which is in radian 
.................... // Date : 9/20/2001 
.................... // 
.................... float32 tan(float32 x) 
.................... { 
....................    float32 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... //Overloaded functions for tan() for PCD 
.................... // Overloaded function tan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tan(float48 x) 
.................... { 
....................    float48 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
....................  
.................... // Overloaded function tan() for data type - Float48 
.................... float64 tan(float64 x) 
.................... { 
....................    float64 c, s; 
....................  
....................    c = cos(x); 
....................    if (c == 0.0) 
....................       return (1.0e+36); 
....................  
....................    s = sin(x); 
....................    return(s/c); 
.................... } 
.................... #endif 
....................  
.................... float32 const pas[3] = {0.49559947, -4.6145309, 5.6036290}; 
.................... float32 const qas[3] = {1.0000000,  -5.5484666, 5.6036290}; 
....................  
.................... float32 ASIN_COS(float32 x, unsigned int8 n) 
.................... { 
....................    float32 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
....................  
.................... //Overloaded functions for ASIN_COS() for PCD 
.................... // Overloaded function ASIN_COS() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 ASIN_COS(float48 x, unsigned int8 n) 
.................... { 
....................    float48 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas[0]*y2 + pas[1]; 
....................    res = res*y2 + pas[2]; 
....................  
....................    r = qas[0]*y2 + qas[1]; 
....................    r = r*y2 + qas[2]; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... // Overloaded function ASIN_COS() for data type - Float64 
.................... double pas_64[5]={1.000000000000000,-2.069938587724477,1.421444580548907, 
....................                  -0.360690137621842,0.024929451660228}; 
....................  
.................... double qas_64[5]={-2.236605254391134,1.719212122946451,-0.524122954476133, 
....................                    0.052808872045749,-0.000662536036570}; 
....................                     
.................... float64 ASIN_COS(float64 x, unsigned int8 n) 
.................... { 
....................    float64 y, res, r, y2; 
....................    int1 s; 
....................    #ifdef _ERRNO 
....................    if(x <-1 || x > 1) 
....................    { 
....................       errno=EDOM; 
....................    } 
....................    #endif 
....................    s = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 0.5) 
....................    { 
....................       y = sqrt((1.0 - y)*0.5); 
....................       n += 2; 
....................    } 
....................  
....................    y2=y*y; 
....................  
....................    res = pas_64[4]*y2 + pas_64[3]; 
....................    res = res*y2 + pas_64[2]; 
....................    res = res*y2 + pas_64[1]; 
....................    res = res*y2 + pas_64[0]; 
....................  
....................    r = qas_64[4]*y2 + qas_64[3]; 
....................    r = r*y2 + qas_64[2]; 
....................    r = r*y2 + qas_64[1]; 
....................    r = r*y2 + qas_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................    if (n & 2)     // |x| > 0.5 
....................       res = PI_DIV_BY_TWO - 2.0*res; 
....................    if (s) 
....................       res = -res; 
....................    if (n & 1)           // take arccos 
....................       res = PI_DIV_BY_TWO - res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float asin(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arcsine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 asin(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for asin() for PCD 
.................... // Overloaded function asin() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 asin(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function asin() for data type - Float64 
.................... float64 asin(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 0); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float acos(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arccosine value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 acos(float32 x) 
.................... { 
....................    float32 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... //Overloaded functions for acos() for PCD 
.................... // Overloaded function acos() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 acos(float48 x) 
.................... { 
....................    float48 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
....................  
.................... // Overloaded function acos() for data type - Float64 
.................... float64 acos(float64 x) 
.................... { 
....................    float64 r; 
....................  
....................    r = ASIN_COS(x, 1); 
....................    return(r); 
.................... } 
.................... #endif 
....................  
.................... float32 const pat[4] = {0.17630401, 5.6710795, 22.376096, 19.818457}; 
.................... float32 const qat[4] = {1.0000000,  11.368190, 28.982246, 19.818457}; 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float atan(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : returns the arctangent value of the value x. 
.................... // Date : N/A 
.................... // 
.................... float32 atan(float32 x) 
.................... { 
....................    float32 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... //Overloaded functions for atan() for PCD 
.................... // Overloaded function atan() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan(float48 x) 
.................... { 
....................    float48 y, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................  
....................    res = pat[0]*y*y + pat[1]; 
....................    res = res*y*y + pat[2]; 
....................    res = res*y*y + pat[3]; 
....................  
....................    r = qat[0]*y*y + qat[1]; 
....................    r = r*y*y + qat[2]; 
....................    r = r*y*y + qat[3]; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
....................  
.................... float64 pat_64[6]={0.999999999999999,2.249923645595566,1.771541617806449, 
....................                    0.579678874003185,0.072162702162882,0.002281100141660}; 
....................  
.................... float64 qat_64[6]={2.583256978928510,2.432627277466967,1.016760379885393, 
....................                    0.182482977188688,0.011155377971690,0.000100013019160}; 
.................... // Overloaded function atan() for data type - Float64 
.................... float64 atan(float64 x) 
.................... { 
....................    float64 y,y2, res, r; 
....................    int1 s, flag; 
....................  
....................    s = 0; 
....................    flag = 0; 
....................    y = x; 
....................  
....................    if (x < 0) 
....................    { 
....................       s = 1; 
....................       y = -y; 
....................    } 
....................  
....................    if (y > 1.0) 
....................    { 
....................       y = 1.0/y; 
....................       flag = 1; 
....................    } 
....................    y2 = y*y; 
....................    res = pat_64[5]*y2 + pat_64[4]; 
....................    res = res*y2 + pat_64[3]; 
....................    res = res*y2 + pat_64[2]; 
....................    res = res*y2 + pat_64[1]; 
....................    res = res*y2 + pat_64[0]; 
....................  
....................    r = qat_64[5]*y2 + qat_64[4]; 
....................    r = r*y2 + qat_64[3]; 
....................    r = r*y2 + qat_64[2]; 
....................    r = r*y2 + qat_64[1]; 
....................    r = r*y2 + qat_64[0]; 
....................    r = r*y2 + 1.0; 
....................  
....................    res = y*res/r; 
....................  
....................  
....................    if (flag)                              // for |x| > 1 
....................       res = PI_DIV_BY_TWO - res; 
....................    if (s) 
....................       res = -res; 
....................  
....................    return(res); 
.................... } 
.................... #endif 
....................  
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... //   float atan2(float y, float x) 
.................... ///////////////////////////////////////////////////////////////////////////// 
.................... // Description :computes the principal value of arc tangent of y/x, using the 
.................... // signs of both the arguments to determine the quadrant of the return value 
.................... // Returns : returns the arc tangent of y/x. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 atan2(float32 y,float32 x) 
.................... { 
....................    float32 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... //Overloaded functions for atan2() for PCD 
.................... // Overloaded function atan2() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 atan2(float48 y,float48 x) 
.................... { 
....................    float48 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
....................  
.................... // Overloaded function atan2() for data type - Float64 
.................... float64 atan2(float64 y,float64 x) 
.................... { 
....................    float64 z; 
....................    int1 sign; 
....................    unsigned int8 quad; 
....................    sign=0; 
....................    quad=0; //quadrant 
....................    quad=((y<=0.0)?((x<=0.0)?3:4):((x<0.0)?2:1)); 
....................    if(y<0.0) 
....................    { 
....................       sign=1; 
....................       y=-y; 
....................    } 
....................    if(x<0.0) 
....................    { 
....................       x=-x; 
....................    } 
....................    if (x==0.0) 
....................    { 
....................       if(y==0.0) 
....................       { 
....................       #ifdef _ERRNO 
....................       { 
....................          errno=EDOM; 
....................       } 
....................       #endif 
....................       } 
....................       else 
....................       { 
....................          if(sign) 
....................          { 
....................          return (-(PI_DIV_BY_TWO)); 
....................          } 
....................          else 
....................          { 
....................          return (PI_DIV_BY_TWO); 
....................          } 
....................       } 
....................    } 
....................    else 
....................    { 
....................       z=y/x; 
....................       switch(quad) 
....................       { 
....................          case 1: 
....................          { 
....................             return atan(z); 
....................             break; 
....................          } 
....................          case 2: 
....................          { 
.................... //            return (atan(z)+PI_DIV_BY_TWO);  //2L3122 
....................             return (PI-atan(z)); 
....................             break; 
....................          } 
....................          case 3: 
....................          { 
....................             return (atan(z)-PI); 
....................             break; 
....................          } 
....................          case 4: 
....................          { 
....................             return (-atan(z)); 
....................             break; 
....................          } 
....................       } 
....................    } 
.................... } 
.................... #endif 
....................  
.................... //////////////////// Hyperbolic functions //////////////////// 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float cosh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic cosine value of x 
.................... // Returns : returns the hyperbolic cosine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 cosh(float32 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for cosh() for PCD 
.................... // Overloaded function cosh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 cosh(float48 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function cosh() for data type - Float64 
.................... float64 cosh(float64 x) 
.................... { 
....................    return ((exp(x)+exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float sinh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic sine value of x 
.................... // Returns : returns the hyperbolic sine value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 sinh(float32 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... //Overloaded functions for sinh() for PCD 
.................... // Overloaded function sinh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 sinh(float48 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
....................  
.................... // Overloaded function sinh() for data type - Float48 
.................... float64 sinh(float64 x) 
.................... { 
....................  
....................    return ((exp(x) - exp(-x))*0.5); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float tanh(float x) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : Computes the hyperbolic tangent value of x 
.................... // Returns : returns the hyperbolic tangent value of x 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 tanh(float32 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... //Overloaded functions for tanh() for PCD 
.................... // Overloaded function tanh() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 tanh(float48 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
....................  
.................... // Overloaded function tanh() for data type - Float64 
.................... float64 tanh(float64 x) 
.................... { 
....................    return(sinh(x)/cosh(x)); 
.................... } 
.................... #endif 
....................  
.................... //////////////////////////////////////////////////////////////////////////// 
.................... //   float frexp(float x, signed int *exp) 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... // Description : breaks a floating point number into a normalized fraction and an integral 
.................... // power of 2. It stores the integer in the signed int object pointed to by exp. 
.................... // Returns : returns the value x, such that x is a double with magnitude in the interval 
.................... // [1/2,1) or zero, and value equals x times 2 raised to the power *exp.If value is zero, 
.................... // both parts of the result are zero. 
.................... // Date : N/A 
.................... // 
....................  
.................... #define LOG2 .30102999566398119521 
.................... #define LOG2_INV 3.32192809488736234787 
.................... float32 frexp(float32 x, signed int8 *exp) 
.................... { 
....................    float32 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... //Overloaded functions for frexp() for PCD 
.................... // Overloaded function frexp() for data type - Float48 
.................... #if defined(__PCD__) 
.................... float48 frexp(float48 x, signed int8 *exp) 
.................... { 
....................    float48 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
....................  
.................... // Overloaded function frexp() for data type - Float64 
.................... float64 frexp(float64 x, signed int8 *exp) 
.................... { 
....................    float64 res; 
....................    int1 sign = 0; 
....................    if(x == 0.0) 
....................    { 
....................       *exp=0; 
....................       return (0.0); 
....................    } 
....................    if(x < 0.0) 
....................    { 
....................      x=-x; 
....................      sign=1; 
....................    } 
....................    if (x > 1.0) 
....................    { 
....................       *exp=(ceil(log10(x)*LOG2_INV)); 
....................       res=x/(pow(2, *exp)); 
....................       if (res == 1) 
....................       { 
....................          *exp=*exp+1; 
....................           res=.5; 
....................       } 
....................    } 
....................    else 
....................    { 
....................       if(x < 0.5) 
....................       { 
....................          *exp=-1; 
....................          res=x*2; 
....................       } 
....................       else 
....................       { 
....................          *exp=0; 
....................           res=x; 
....................       } 
....................    } 
....................    if(sign) 
....................    { 
....................       res=-res; 
....................    } 
....................    return res; 
.................... } 
.................... #endif 
....................  
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... //   float ldexp(float x, signed int *exp) 
.................... ////////////////////////////////////////////////////////////////////////////// 
.................... // Description : multiplies a floating point number by an integral power of 2. 
.................... // Returns : returns the value of x times 2 raised to the power exp. 
.................... // Date : N/A 
.................... // 
....................  
.................... float32 ldexp(float32 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... //Overloaded functions for ldexp() for PCD 
.................... // Overloaded function ldexp() for data type - Float48 
....................  
.................... #if defined(__PCD__) 
.................... float48 ldexp(float48 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... // Overloaded function ldexp() for data type - Float64 
.................... float64 ldexp(float64 value, signed int8 exp) 
.................... { 
....................    return (value * pow(2,exp)); 
.................... } 
.................... #endif 
....................  
.................... #endif 
....................  
.................... #use delay(clock=8000000) 
*
05D5:  MOVLW  73
05D6:  MOVWF  04
05D7:  BCF    03.7
05D8:  MOVF   00,W
05D9:  BTFSC  03.2
05DA:  GOTO   5E8
05DB:  MOVLW  02
05DC:  MOVWF  78
05DD:  CLRF   77
05DE:  DECFSZ 77,F
05DF:  GOTO   5DE
05E0:  DECFSZ 78,F
05E1:  GOTO   5DD
05E2:  MOVLW  97
05E3:  MOVWF  77
05E4:  DECFSZ 77,F
05E5:  GOTO   5E4
05E6:  DECFSZ 00,F
05E7:  GOTO   5DB
05E8:  RETURN
.................... void lcd_init(void);             // Ham dung de khoi dong C.LCD. 
.................... byte lcd_read_byte(void);         // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD. 
.................... byte lcd_read_nibble(void);         // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD. 
.................... void lcd_send_byte(byte address, byte n);   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address). 
.................... void lcd_send_nibble(byte n);      // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD. 
.................... void lcd_gotoxy(byte x, byte y);   // Ham thiet lap vi tri ghi tren C.LCD. 
.................... char lcd_getc(byte x, byte y);      // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD. 
.................... void lcd_putc(char c);            // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD. 
.................... // Khai bao bien. 
.................... // Dinh nghia cac thong so. 
.................... //!#define LCD_RS_PIN         PIN_B1   // Cac ket noi C.LCD voi vi dieu khien. 
.................... //!#define LCD_RW_PIN         PIN_B2 
.................... //!#define LCD_ENABLE_PIN     PIN_B3 
.................... //!#define LCD_DATA4          PIN_B4 
.................... //!#define LCD_DATA5          PIN_B5 
.................... //!#define LCD_DATA6          PIN_B6 
.................... //!#define LCD_DATA7          PIN_B7  
....................  
.................... //!#define LCD_RS_PIN         PIN_C0   // Cac ket noi C.LCD voi vi dieu khien. 
.................... //!#define LCD_RW_PIN         PIN_C1 
.................... //!#define LCD_ENABLE_PIN     PIN_C2 
.................... //!#define LCD_DATA4          PIN_C3 
.................... //!#define LCD_DATA5          PIN_C4 
.................... //!#define LCD_DATA6          PIN_C5 
.................... //!#define LCD_DATA7          PIN_C6 
.................... //! 
....................  
.................... #define LCD_RS_PIN      PIN_D0   // Cac ket noi C.LCD voi vi dieu khien. 
.................... #define LCD_RW_PIN      PIN_D1 
.................... #define LCD_ENABLE_PIN  PIN_D2 
.................... #define LCD_DATA4       PIN_D3 
.................... #define LCD_DATA5       PIN_D4 
.................... #define LCD_DATA6       PIN_D5 
.................... #define LCD_DATA7       PIN_D6   
....................  
.................... #define lcd_output_enable(x)   output_bit(LCD_ENABLE_PIN, x)   // Lenh dieu khien chan LCD_ENABLE_PIN. 
.................... #define lcd_enable_tris()   output_drive(LCD_ENABLE_PIN) 
....................  
.................... #define lcd_output_rs(x)   output_bit(LCD_RS_PIN, x)   // Lenh dieu khien chan LCD_RS_PIN. 
.................... #define lcd_rs_tris()      output_drive(LCD_RS_PIN) 
....................  
.................... #define lcd_output_rw(x)   output_bit(LCD_RW_PIN, x)   // Lenh dieu khien chan LCD_RW_PIN 
.................... #define lcd_rw_tris()      output_drive(LCD_RW_PIN) 
....................  
.................... #define lcd_line_one   0x00    // Dia chi RAM C.LCD cho hang thu 1. 
.................... #define lcd_line_two   0x40    // Dia chi RAM C.LCD cho hang thu 2. 
.................... #define lcd_line_three   0x14 
.................... #define lcd_line_four   0x54 
.................... #define LCD_TYPE 0x02           // Thong tin cau hinh C.LCD: 0x00=5x7, 0x01=5x10, 0x02=2 lines 
....................  
.................... // Dinh nghia cac hang so. 
.................... byte const LCD_INIT_STRING[4] = {0x28 | (LCD_TYPE << 2), 0x0C, 0x01, 0x06}; 
....................         // Cac byte nay can thiet de gui toi C.LCD, dung de khoi dong cau hinh hoat dong cho C.LCD. 
....................       // Byte 1: 0x20 | (LCD_TYPE << 2) - So bit du lieu giao tiep (DL), so dong hien thi (N), kieu ky tu (F). 
....................       //         0 0 1 DL N F x x (DL: Data Length, N: Number Line, F: Font). 
....................          // Truong hop 1: 0x20 - 4 bit / 1 dong / 5 x 7. 
....................          // Truong hop 2: 0x24 - 4 bit / 1 dong / 5 x 10. 
....................          // Truong hop 3: 0x28 - 4 bit / 2 dong / 5 x 7. 
....................       // Byte 2: 0x0C - Dieu khien hien thi (Bat hien thi, tat con tro, tat nhap nhay con tro). 
....................       //         0 0 0 0 1 D C B (D: Display, C: Cursor, B: Blink). 
....................       // Byte 3: 0x01 - Xoa hien thi va tra con tro ve dau dong. 
....................       // Byte 4: 0x06 - Dat che do dau vao (Che do tang dia chi, tat dich chuyen hien thi). 
....................       //         0 0 0 0 0 1 I/D S (I/D: Increment/Decrement, S: Shift). 
....................       // Byte 5: .... - Doi con tro / hien thi. 
....................       //         0 0 0 1 S/C R/L x x (S/C: Screen/Cursor, R/L: Right/Left). 
....................  
.................... // *************************************************** 
.................... void lcd_init(void)    // Ham dung de khoi dong C.LCD. 
.................... { 
.................... // Khai bao bien. 
.................... byte i; 
.................... // Dinh nghia ham. 
.................... output_drive(LCD_DATA4);   // Thiet lap chan port (Data) o che do ngo ra. 
*
06A5:  BSF    03.5
06A6:  BCF    08.3
.................... output_drive(LCD_DATA5); 
06A7:  BCF    08.4
.................... output_drive(LCD_DATA6); 
06A8:  BCF    08.5
.................... output_drive(LCD_DATA7); 
06A9:  BCF    08.6
....................  
.................... lcd_enable_tris();         // Thiet lap chan port (Control: EN, RS, RW) o che do ngo ra. 
06AA:  BCF    08.2
.................... lcd_rs_tris(); 
06AB:  BCF    08.0
.................... lcd_rw_tris(); 
06AC:  BCF    08.1
....................  
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh. 
06AD:  BCF    03.5
06AE:  BCF    08.0
06AF:  BSF    03.5
06B0:  BCF    08.0
.................... lcd_output_rw(0);         // RW = 0 - Ghi thong tin vao C.LCD. 
06B1:  BCF    03.5
06B2:  BCF    08.1
06B3:  BSF    03.5
06B4:  BCF    08.1
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD. 
06B5:  BCF    03.5
06B6:  BCF    08.2
06B7:  BSF    03.5
06B8:  BCF    08.2
....................  
.................... delay_ms(15);   // Tao thoi gian tre 15ms (Thoi gian de LCD tu reset khi moi duoc cap nguon). 
06B9:  MOVLW  0F
06BA:  MOVWF  73
06BB:  BCF    03.5
06BC:  CALL   5D5
....................  
.................... for(i=1;i<=3;i++)         // Doan lenh khoi dong C.LCD o che do 8 bit duoc thuc hien 3 lan lien tiep 
06BD:  MOVLW  01
06BE:  MOVWF  65
06BF:  MOVF   65,W
06C0:  SUBLW  03
06C1:  BTFSS  03.0
06C2:  GOTO   6CB
....................    {                  // tai thoi diem ban dau (de dam bao cho C.LCD hoat dong on dinh trong  
....................    lcd_send_nibble(0x03);    // truong hop khi cung cap nguon cho C.LCD ma dien ap nguon tang len cham). 
06C3:  MOVLW  03
06C4:  MOVWF  7E
06C5:  CALL   5E9
....................    delay_ms(5);         // RS = 0, RW = 0, D7 - D4 = 0011 (0x03) -> DL = 1 (8 bit). 
06C6:  MOVLW  05
06C7:  MOVWF  73
06C8:  CALL   5D5
06C9:  INCF   65,F
06CA:  GOTO   6BF
....................    }                  // Do co BF (Busy Flag) chua kiem tra duoc trong thoi diem nay, nen phai  
....................                      // thuc hien 3 lan (xem luu do khoi dong C.LCD cua nha san xuat). 
....................  
.................... lcd_send_nibble(0x02);      // Doan lenh khoi dong C.LCD o che do 4 bit. Tu luc nay thi 4 bit cao duoc ghi 
06CB:  MOVLW  02
06CC:  MOVWF  7E
06CD:  CALL   5E9
....................                      // ra truoc tien, sau do la 4 bit thap. 
....................                      // RS = 0, RW = 0, D7 - D4 = 0010 (0x02) -> DL = 0 (4 bit). 
....................                      // Co BF (Busy Flag) co the bat dau kiem tra duoc tu luc nay. 
....................  
.................... for(i=0;i<=3;i++) 
06CE:  CLRF   65
06CF:  MOVF   65,W
06D0:  SUBLW  03
06D1:  BTFSS  03.0
06D2:  GOTO   6DC
....................    lcd_send_byte(0,LCD_INIT_STRING[i]);   // Goi ham truyen thong tin (lenh) sang C.LCD. 
06D3:  MOVF   65,W
06D4:  CALL   038
06D5:  MOVWF  66
06D6:  CLRF   7B
06D7:  MOVF   66,W
06D8:  MOVWF  7C
06D9:  CALL   64E
06DA:  INCF   65,F
06DB:  GOTO   6CF
06DC:  BCF    0A.3
06DD:  BSF    0A.4
06DE:  GOTO   080 (RETURN)
.................... }                                 // Lenh: Thiet lap cau hinh hoat dong cho C.LCD. 
....................  
.................... // *************************************************** 
.................... byte lcd_read_byte(void)   // Ham xu ly doc thong tin (dang 8 bit) tu thong tin dang 4 bit tu C.LCD. 
.................... { 
.................... // Khai bao bien. 
.................... byte low,high; 
.................... // Dinh nghia ham. 
.................... output_float(LCD_DATA4);   // Thiet lap chan port o che do ngo vao. 
*
0651:  BSF    08.3
.................... output_float(LCD_DATA5); 
0652:  BSF    08.4
.................... output_float(LCD_DATA6); 
0653:  BSF    08.5
.................... output_float(LCD_DATA7); 
0654:  BSF    08.6
....................  
.................... lcd_output_rw(1);         // RW = 1 - Doc thong tin tu C.LCD. 
0655:  BCF    03.5
0656:  BSF    08.1
0657:  BSF    03.5
0658:  BCF    08.1
....................                   // Tien hanh doc 4 bit cao cua thong tin tu C.LCD. 
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
0659:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD. 
065A:  BCF    03.5
065B:  BSF    08.2
065C:  BSF    03.5
065D:  BCF    08.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
065E:  NOP
.................... high = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit cao). 
065F:  BCF    03.5
0660:  CALL   61B
0661:  MOVF   78,W
0662:  MOVWF  7E
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD. 
0663:  BCF    08.2
0664:  BSF    03.5
0665:  BCF    08.2
....................                   // Tien hanh doc 4 bit thap cua thong tin tu C.LCD. 
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
0666:  NOP
.................... lcd_output_enable(1);      // EN = 1 - Cho phep truy xuat C.LCD. 
0667:  BCF    03.5
0668:  BSF    08.2
0669:  BSF    03.5
066A:  BCF    08.2
.................... delay_cycles(1);         // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
066B:  NOP
.................... low = lcd_read_nibble();   // Cat tam 4 bit du lieu (4 bit thap). 
066C:  BCF    03.5
066D:  CALL   61B
066E:  MOVF   78,W
066F:  MOVWF  7D
.................... lcd_output_enable(0);      // EN = 0 - Cam truy xuat C.LCD. 
0670:  BCF    08.2
0671:  BSF    03.5
0672:  BCF    08.2
....................  
.................... output_drive(LCD_DATA4);   // Thiet lap chan port o che do ngo ra. 
0673:  BCF    08.3
.................... output_drive(LCD_DATA5); 
0674:  BCF    08.4
.................... output_drive(LCD_DATA6); 
0675:  BCF    08.5
.................... output_drive(LCD_DATA7); 
0676:  BCF    08.6
....................  
.................... return((high<<4) | low);   // Tra ve ket qua du lieu (dang 8 bit). 
0677:  SWAPF  7E,W
0678:  MOVWF  77
0679:  MOVLW  F0
067A:  ANDWF  77,F
067B:  MOVF   77,W
067C:  IORWF  7D,W
067D:  MOVWF  78
.................... } 
....................  
.................... // *************************************************** 
.................... byte lcd_read_nibble(void)   // Ham doc thong tin (dang 4 bit / nibble) tu C.LCD. 
*
061B:  BSF    03.5
061C:  CLRF   20
.................... { 
.................... // Khai bao bien. 
.................... byte n = 0x00;   // Mac dinh gia tri ban dau cho noi chua se thong tin. 
.................... // Dinh nghia ham. 
.................... n |= input(LCD_DATA4);         // Doc lan luot cac bit tu bus du lieu. 
061D:  BSF    08.3
061E:  MOVLW  00
061F:  BCF    03.5
0620:  BTFSC  08.3
0621:  MOVLW  01
0622:  BSF    03.5
0623:  IORWF  20,F
.................... n |= input(LCD_DATA5) << 1; 
0624:  BSF    08.4
0625:  MOVLW  00
0626:  BCF    03.5
0627:  BTFSC  08.4
0628:  MOVLW  01
0629:  MOVWF  77
062A:  BCF    03.0
062B:  RLF    77,F
062C:  MOVF   77,W
062D:  BSF    03.5
062E:  IORWF  20,F
.................... n |= input(LCD_DATA6) << 2; 
062F:  BSF    08.5
0630:  MOVLW  00
0631:  BCF    03.5
0632:  BTFSC  08.5
0633:  MOVLW  01
0634:  MOVWF  77
0635:  RLF    77,F
0636:  RLF    77,F
0637:  MOVLW  FC
0638:  ANDWF  77,F
0639:  MOVF   77,W
063A:  BSF    03.5
063B:  IORWF  20,F
.................... n |= input(LCD_DATA7) << 3; 
063C:  BSF    08.6
063D:  MOVLW  00
063E:  BCF    03.5
063F:  BTFSC  08.6
0640:  MOVLW  01
0641:  MOVWF  77
0642:  RLF    77,F
0643:  RLF    77,F
0644:  RLF    77,F
0645:  MOVLW  F8
0646:  ANDWF  77,F
0647:  MOVF   77,W
0648:  BSF    03.5
0649:  IORWF  20,F
....................  
.................... return(n);   // Tra ve ket qua doc duoc (data = 0000 xxxx). 
064A:  MOVF   20,W
064B:  MOVWF  78
064C:  BCF    03.5
064D:  RETURN
.................... } 
....................  
.................... // *************************************************** 
.................... void lcd_send_byte(byte address, byte n)   // Ham gui thong tin (byte) toi C.LCD tai dia chi (address). 
.................... {                                 // address = 0: Lenh / 1: Du lieu. 
....................                                  // byte = Thong tin can gui (8 bit). 
.................... // Khai bao bien. 
....................  
.................... // Dinh nghia ham.   
.................... lcd_output_rs(0);      // RS = 0 - Databus = Bus lenh. 
064E:  BCF    08.0
064F:  BSF    03.5
0650:  BCF    08.0
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong). 
*
067E:  MOVF   78,W
067F:  MOVWF  7D
0680:  BTFSC  7D.7
0681:  GOTO   651
.................... lcd_output_rs(address);   // RS = address - Databus = Bus lenh/du lieu. 
0682:  MOVF   7B,F
0683:  BTFSS  03.2
0684:  GOTO   689
0685:  BCF    03.5
0686:  BCF    08.0
0687:  GOTO   68B
0688:  BSF    03.5
0689:  BCF    03.5
068A:  BSF    08.0
068B:  BSF    03.5
068C:  BCF    08.0
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
068D:  NOP
.................... lcd_output_rw(0);      // RW = 0 - Ghi thong tin vao C.LCD. 
068E:  BCF    03.5
068F:  BCF    08.1
0690:  BSF    03.5
0691:  BCF    08.1
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
0692:  NOP
.................... lcd_output_enable(0);   // EN = 0 - Cam truy xuat C.LCD. 
0693:  BCF    03.5
0694:  BCF    08.2
0695:  BSF    03.5
0696:  BCF    08.2
.................... lcd_send_nibble(n >> 4);   // Goi ham truyen 4 bit cao sang C.LCD. 
0697:  SWAPF  7C,W
0698:  MOVWF  7D
0699:  MOVLW  0F
069A:  ANDWF  7D,F
069B:  MOVF   7D,W
069C:  MOVWF  7E
069D:  BCF    03.5
069E:  CALL   5E9
.................... lcd_send_nibble(n & 0x0F);   // Goi ham truyen 4 bit thap sang C.LCD. 
069F:  MOVF   7C,W
06A0:  ANDLW  0F
06A1:  MOVWF  7D
06A2:  MOVWF  7E
06A3:  CALL   5E9
06A4:  RETURN
.................... } 
....................  
.................... // *************************************************** 
.................... void lcd_send_nibble(byte n)   // Ham gui thong tin (dang 4 bit / nibble) sang C.LCD. 
.................... {                        // n = Thong tin can gui. 4 bit can gui phai nam vi tri 4 bit thap. 
.................... // Khai bao bien. 
....................  
.................... // Dinh nghia ham.  
.................... output_bit(LCD_DATA4, bit_test(n, 0));   // Xuat lan luot cac bit len bus du lieu. 
*
05E9:  BTFSC  7E.0
05EA:  GOTO   5ED
05EB:  BCF    08.3
05EC:  GOTO   5EE
05ED:  BSF    08.3
05EE:  BSF    03.5
05EF:  BCF    08.3
.................... output_bit(LCD_DATA5, bit_test(n, 1)); 
05F0:  BTFSC  7E.1
05F1:  GOTO   5F6
05F2:  BCF    03.5
05F3:  BCF    08.4
05F4:  GOTO   5F8
05F5:  BSF    03.5
05F6:  BCF    03.5
05F7:  BSF    08.4
05F8:  BSF    03.5
05F9:  BCF    08.4
.................... output_bit(LCD_DATA6, bit_test(n, 2)); 
05FA:  BTFSC  7E.2
05FB:  GOTO   600
05FC:  BCF    03.5
05FD:  BCF    08.5
05FE:  GOTO   602
05FF:  BSF    03.5
0600:  BCF    03.5
0601:  BSF    08.5
0602:  BSF    03.5
0603:  BCF    08.5
.................... output_bit(LCD_DATA7, bit_test(n, 3)); 
0604:  BTFSC  7E.3
0605:  GOTO   60A
0606:  BCF    03.5
0607:  BCF    08.6
0608:  GOTO   60C
0609:  BSF    03.5
060A:  BCF    03.5
060B:  BSF    08.6
060C:  BSF    03.5
060D:  BCF    08.6
....................      
.................... delay_cycles(1);      // Tao tre 1 chu ky (t=1us voi fosc=4MHz). 
060E:  NOP
.................... lcd_output_enable(1);   // Tao xung ghi thong tin vao C.LCD. 
060F:  BCF    03.5
0610:  BSF    08.2
0611:  BSF    03.5
0612:  BCF    08.2
.................... delay_us(2);         // Tao tre 2 chu ky (t=2us voi fosc=4MHz). 
0613:  GOTO   614
0614:  GOTO   615
.................... lcd_output_enable(0);   // Tao xung ghi thong tin vao LCD - EN = 1->0 (High to Low). 
0615:  BCF    03.5
0616:  BCF    08.2
0617:  BSF    03.5
0618:  BCF    08.2
0619:  BCF    03.5
061A:  RETURN
.................... } 
....................  
.................... // *************************************************** 
.................... void lcd_gotoxy(byte x, byte y)   // Ham thiet lap vi tri ghi tren C.LCD (Goc tren ben trai co toa do la 1,1). 
.................... { 
.................... // Khai bao bien. 
.................... byte address; 
.................... // Dinh nghia ham.   
.................... if(y==1)               // Kiem tra vi tri truy xuat thuoc hang 2. 
*
06DF:  DECFSZ 74,W
06E0:  GOTO   6E3
....................    address=lcd_line_one;      // Nap dia chi RAM cua hang 2.  
06E1:  CLRF   75
06E2:  GOTO   6F7
.................... else if(y==2)      // Neu vi tri truy xuat thuoc hang 1. 
06E3:  MOVF   74,W
06E4:  SUBLW  02
06E5:  BTFSS  03.2
06E6:  GOTO   6EA
....................    address=lcd_line_two;      // Nap dia chi RAM cua hang 1. 
06E7:  MOVLW  40
06E8:  MOVWF  75
06E9:  GOTO   6F7
.................... else if(y==3) 
06EA:  MOVF   74,W
06EB:  SUBLW  03
06EC:  BTFSS  03.2
06ED:  GOTO   6F1
....................    address=lcd_line_three;      
06EE:  MOVLW  14
06EF:  MOVWF  75
06F0:  GOTO   6F7
.................... else if(y==4) 
06F1:  MOVF   74,W
06F2:  SUBLW  04
06F3:  BTFSS  03.2
06F4:  GOTO   6F7
....................    address=lcd_line_four;    
06F5:  MOVLW  54
06F6:  MOVWF  75
....................  
.................... address+=x-1;               // Ghep dia chi cot vao dia chi tong quat (address). address = address + (x-1).       
06F7:  MOVLW  01
06F8:  SUBWF  73,W
06F9:  ADDWF  75,F
....................                         // Ta qui uoc: Goc tren ben trai co toa do la 1,1 -> Cot dau tien la Cot 1 
....................                         // (x-1) vi C.LCD qui uoc cot dau tien co dia chi la 0. 
.................... lcd_send_byte(0,0x80|address);   // Goi ham truyen thong tin (lenh) sang C.LCD. 
06FA:  MOVF   75,W
06FB:  IORLW  80
06FC:  MOVWF  76
06FD:  CLRF   7B
06FE:  MOVF   76,W
06FF:  MOVWF  7C
0700:  CALL   64E
0701:  RETURN
.................... }                        // Lenh: Thiet lap dia chi DDRAM cua C.LCD (addresss).    
....................  
.................... // *************************************************** 
.................... char lcd_getc(byte x, byte y)   // Ham tra ve ky tu tai vi tri (x,y) tren C.LCD. 
.................... { 
.................... // Khai bao bien. 
.................... char value; 
.................... // Dinh nghia ham.   
.................... lcd_gotoxy(x,y);            // Xac dinh toa do C.LCD can truy xuat. 
.................... while(bit_test(lcd_read_byte(),7));   // Cho Busy Flag = 0 (C.LCD da xu ly xong). 
.................... lcd_output_rs(1);         // RS = 1 - Databus = Bus du lieu. 
.................... value = lcd_read_byte();   // Doc ve tu C.LCD. 
.................... lcd_output_rs(0);         // RS = 0 - Databus = Bus lenh. 
....................  
.................... return(value);      // Tra ve ma ky tu tai toa do yeu cau. 
.................... } 
....................  
.................... // *************************************************** 
.................... void lcd_putc(char c)   // Ham se hien thi ky tu c tai vi tri ke tiep tren C.LCD. 
.................... { 
.................... // Khai bao bien. 
....................  
.................... // Dinh nghia ham.  
.................... switch (c) 
0702:  MOVF   72,W
0703:  XORLW  0C
0704:  BTFSC  03.2
0705:  GOTO   70D
0706:  XORLW  06
0707:  BTFSC  03.2
0708:  GOTO   715
0709:  XORLW  02
070A:  BTFSC  03.2
070B:  GOTO   71B
070C:  GOTO   720
....................    { 
....................    case '\f':     // Chuc nang xoa hien thi. 
....................       lcd_send_byte(0,0x01);   // Goi ham truyen thong tin (lenh) sang C.LCD. 
070D:  CLRF   7B
070E:  MOVLW  01
070F:  MOVWF  7C
0710:  CALL   64E
....................       delay_ms(2);         // Lenh: Xoa hien thi tren man hinh C.LCD (0x01). 
0711:  MOVLW  02
0712:  MOVWF  73
0713:  CALL   5D5
....................       break; 
0714:  GOTO   725
....................    case '\n':       // Chuc nang bat dau hang thu 2. 
....................       lcd_gotoxy(1,0x02);     // Goi ham truyen thong tin (du lieu) sang C.LCD.    
0715:  MOVLW  01
0716:  MOVWF  73
0717:  MOVLW  02
0718:  MOVWF  74
0719:  CALL   6DF
....................       break; 
071A:  GOTO   725
....................     case '\b':       // Chuc nang lui ve 1 vi tri. 
....................       lcd_send_byte(0,0x10);    // Goi ham truyen thong tin (lenh) sang C.LCD.  
071B:  CLRF   7B
071C:  MOVLW  10
071D:  MOVWF  7C
071E:  CALL   64E
....................       break;               // Lenh: Doi con tro sang trai (0x10). 
071F:  GOTO   725
....................    default:       // Chuc nang hien thi ky tu c tai vi tri ke tiep tren C.LCD. 
....................       lcd_send_byte(1,c);     // Goi ham truyen thong tin (du lieu) sang C.LCD. 
0720:  MOVLW  01
0721:  MOVWF  7B
0722:  MOVF   72,W
0723:  MOVWF  7C
0724:  CALL   64E
....................       break; 
....................    } 
0725:  RETURN
.................... }       
.................... // ***************************************************    
....................  
.................... #include "ds18b20.h" 
....................  
....................  
.................... #define DS18B20_PIN PIN_B1 
.................... #use delay(clock = 8MHz) 
*
07C1:  MOVLW  08
07C2:  SUBWF  68,F
07C3:  BTFSS  03.0
07C4:  GOTO   7D1
07C5:  MOVLW  68
07C6:  MOVWF  04
07C7:  BCF    03.7
07C8:  BCF    03.0
07C9:  RRF    00,F
07CA:  MOVF   00,W
07CB:  BTFSC  03.2
07CC:  GOTO   7D1
07CD:  GOTO   7CF
07CE:  NOP
07CF:  DECFSZ 00,F
07D0:  GOTO   7CE
07D1:  RETURN
*
09B8:  MOVLW  65
09B9:  MOVWF  04
09BA:  BCF    03.7
09BB:  MOVF   00,W
09BC:  BTFSC  03.2
09BD:  GOTO   1CB
09BE:  MOVLW  02
09BF:  MOVWF  78
09C0:  CLRF   77
09C1:  DECFSZ 77,F
09C2:  GOTO   1C1
09C3:  DECFSZ 78,F
09C4:  GOTO   1C0
09C5:  MOVLW  97
09C6:  MOVWF  77
09C7:  DECFSZ 77,F
09C8:  GOTO   1C7
09C9:  DECFSZ 00,F
09CA:  GOTO   1BE
....................  
.................... signed int16 raw_temp; 
.................... float temp; 
....................  
.................... int1 ds18b20_start(){ 
....................   output_low(DS18B20_PIN);                          
*
07D2:  BSF    03.5
07D3:  BCF    06.1
07D4:  BCF    03.5
07D5:  BCF    06.1
....................   output_drive(DS18B20_PIN);                        
07D6:  BSF    03.5
07D7:  BCF    06.1
....................   delay_us(500);                                   
07D8:  MOVLW  02
07D9:  BCF    03.5
07DA:  MOVWF  67
07DB:  MOVLW  F8
07DC:  MOVWF  68
07DD:  CALL   7C1
07DE:  DECFSZ 67,F
07DF:  GOTO   7DB
....................   output_float(DS18B20_PIN);                        
07E0:  BSF    03.5
07E1:  BSF    06.1
....................   delay_us(100);                                    
07E2:  MOVLW  42
07E3:  MOVWF  77
07E4:  DECFSZ 77,F
07E5:  GOTO   7E4
07E6:  NOP
....................   if (!input(DS18B20_PIN)) { 
07E7:  BSF    06.1
07E8:  BCF    03.5
07E9:  BTFSC  06.1
07EA:  GOTO   7F5
....................     delay_us(400);                                  
07EB:  MOVLW  02
07EC:  MOVWF  67
07ED:  MOVLW  C6
07EE:  MOVWF  68
07EF:  CALL   7C1
07F0:  DECFSZ 67,F
07F1:  GOTO   7ED
....................     return TRUE;                                    
07F2:  MOVLW  01
07F3:  MOVWF  78
07F4:  GOTO   7F7
....................   } 
....................   return FALSE; 
07F5:  MOVLW  00
07F6:  MOVWF  78
07F7:  RETURN
.................... } 
....................  
.................... void ds18b20_write_bit(int1 value){ 
....................   output_low(DS18B20_PIN); 
*
0815:  BSF    03.5
0816:  BCF    06.1
0817:  BCF    03.5
0818:  BCF    06.1
....................   output_drive(DS18B20_PIN);                        
0819:  BSF    03.5
081A:  BCF    06.1
....................   delay_us(2);                                     
081B:  GOTO   01C
081C:  GOTO   01D
....................   output_bit(DS18B20_PIN, value); 
081D:  BCF    03.5
081E:  MOVF   6A,F
081F:  BTFSS  03.2
0820:  GOTO   023
0821:  BCF    06.1
0822:  GOTO   024
0823:  BSF    06.1
0824:  BSF    03.5
0825:  BCF    06.1
....................   delay_us(80);                                     
0826:  MOVLW  34
0827:  MOVWF  77
0828:  DECFSZ 77,F
0829:  GOTO   028
082A:  GOTO   02B
082B:  NOP
....................   output_float(DS18B20_PIN);                      
082C:  BSF    06.1
....................   delay_us(2);                                     
082D:  GOTO   02E
082E:  GOTO   02F
.................... } 
....................  
.................... void ds18b20_write_byte(int8 value){ 
....................   int8 i; 
....................   for(i = 0; i < 8; i++) 
*
0800:  CLRF   68
0801:  MOVF   68,W
0802:  SUBLW  07
0803:  BTFSS  03.0
0804:  GOTO   032
....................     ds18b20_write_bit(bit_test(value, i)); 
0805:  MOVF   67,W
0806:  MOVWF  77
0807:  MOVF   68,W
0808:  MOVWF  78
0809:  BTFSC  03.2
080A:  GOTO   00F
080B:  BCF    03.0
080C:  RRF    77,F
080D:  DECFSZ 78,F
080E:  GOTO   00B
080F:  MOVLW  00
0810:  BTFSC  77.0
0811:  MOVLW  01
0812:  MOVWF  69
0813:  MOVF   69,W
0814:  MOVWF  6A
*
082F:  BCF    03.5
0830:  INCF   68,F
0831:  GOTO   001
0832:  RETURN
.................... } 
....................  
.................... int1 ds18b20_read_bit(void) { 
....................   int1 value; 
....................   output_low(DS18B20_PIN); 
*
0839:  BSF    03.5
083A:  BCF    06.1
083B:  BCF    03.5
083C:  BCF    06.1
....................   output_drive(DS18B20_PIN);                       
083D:  BSF    03.5
083E:  BCF    06.1
....................   delay_us(2); 
083F:  GOTO   040
0840:  GOTO   041
....................   output_float(DS18B20_PIN);                        
0841:  BSF    06.1
....................   delay_us(5);                                     
0842:  MOVLW  02
0843:  MOVWF  77
0844:  DECFSZ 77,F
0845:  GOTO   044
0846:  GOTO   047
0847:  NOP
....................   value = input(DS18B20_PIN); 
0848:  BSF    06.1
0849:  BCF    03.5
084A:  BCF    6D.0
084B:  BTFSC  06.1
084C:  BSF    6D.0
....................   delay_us(100);                                    
084D:  MOVLW  42
084E:  MOVWF  77
084F:  DECFSZ 77,F
0850:  GOTO   04F
0851:  NOP
....................   return value; 
0852:  MOVLW  00
0853:  BTFSC  6D.0
0854:  MOVLW  01
0855:  MOVWF  78
.................... } 
....................  
.................... int8 ds18b20_read_byte(void) { 
*
0833:  CLRF   6C
....................   int8 i, value = 0; 
....................   for(i = 0; i  < 8; i++) 
0834:  CLRF   6B
0835:  MOVF   6B,W
0836:  SUBLW  07
0837:  BTFSS  03.0
0838:  GOTO   05F
....................     shift_right(&value, 1, ds18b20_read_bit()); 
*
0856:  MOVF   78,F
0857:  BTFSS  03.2
0858:  GOTO   05B
0859:  BCF    03.0
085A:  GOTO   05C
085B:  BSF    03.0
085C:  RRF    6C,F
085D:  INCF   6B,F
085E:  GOTO   035
....................   return value; 
085F:  MOVF   6C,W
0860:  MOVWF  78
0861:  RETURN
.................... } 
....................  
.................... int1 ds18b20_read(int16 *raw_temp_value) { 
....................   if (!ds18b20_start())                      
0862:  BCF    0A.3
0863:  CALL   7D2
0864:  BSF    0A.3
0865:  MOVF   78,F
0866:  BTFSS  03.2
0867:  GOTO   06B
....................     return FALSE; 
0868:  MOVLW  00
0869:  MOVWF  78
086A:  GOTO   0BB
....................   ds18b20_write_byte(0xCC);                  
086B:  MOVLW  CC
086C:  MOVWF  67
086D:  CALL   000
....................   ds18b20_write_byte(0x44);                  
086E:  MOVLW  44
086F:  MOVWF  67
0870:  CALL   000
....................   while(ds18b20_read_byte() == 0);           
0871:  CALL   033
0872:  MOVF   78,F
0873:  BTFSC  03.2
0874:  GOTO   071
....................   if (!ds18b20_start())                      
0875:  BCF    0A.3
0876:  CALL   7D2
0877:  BSF    0A.3
0878:  MOVF   78,F
0879:  BTFSS  03.2
087A:  GOTO   07E
....................     return FALSE;                            
087B:  MOVLW  00
087C:  MOVWF  78
087D:  GOTO   0BB
....................   ds18b20_write_byte(0xCC);                  
087E:  MOVLW  CC
087F:  MOVWF  67
0880:  CALL   000
....................   ds18b20_write_byte(0xBE);                 
0881:  MOVLW  BE
0882:  MOVWF  67
0883:  CALL   000
....................   *raw_temp_value = ds18b20_read_byte();     
0884:  MOVF   66,W
0885:  MOVWF  7A
0886:  MOVF   65,W
0887:  MOVWF  67
0888:  MOVF   66,W
0889:  MOVWF  68
088A:  CALL   033
088B:  MOVF   67,W
088C:  MOVWF  04
088D:  BCF    03.7
088E:  BTFSC  68.0
088F:  BSF    03.7
0890:  INCF   04,F
0891:  CLRF   00
0892:  DECF   04,F
0893:  MOVF   78,W
0894:  MOVWF  00
....................   *raw_temp_value |= (int16)(ds18b20_read_byte()) << 8;      
0895:  MOVF   66,W
0896:  MOVWF  7A
0897:  MOVF   65,W
0898:  MOVWF  67
0899:  MOVF   66,W
089A:  MOVWF  68
089B:  MOVF   65,W
089C:  MOVWF  04
089D:  BCF    03.7
089E:  BTFSC  66.0
089F:  BSF    03.7
08A0:  INCF   04,F
08A1:  MOVF   00,W
08A2:  MOVWF  6A
08A3:  DECF   04,F
08A4:  MOVF   00,W
08A5:  MOVWF  69
08A6:  CALL   033
08A7:  CLRF   6C
08A8:  MOVLW  00
08A9:  IORWF  69,W
08AA:  MOVWF  77
08AB:  MOVF   78,W
08AC:  IORWF  6A,W
08AD:  MOVWF  7A
08AE:  MOVF   67,W
08AF:  MOVWF  04
08B0:  BCF    03.7
08B1:  BTFSC  68.0
08B2:  BSF    03.7
08B3:  INCF   04,F
08B4:  MOVF   7A,W
08B5:  MOVWF  00
08B6:  DECF   04,F
08B7:  MOVF   77,W
08B8:  MOVWF  00
....................   return TRUE;                                 
08B9:  MOVLW  01
08BA:  MOVWF  78
08BB:  BCF    0A.3
08BC:  BSF    0A.4
08BD:  GOTO   287 (RETURN)
.................... } 
....................  
....................  
.................... #include "dht11.h" 
....................  
.................... #define DHT11_PIN PIN_B4  
....................  
.................... short Time_out; 
....................  
....................  
....................  
.................... char message1[] = "SICAKLIK=00.0 C"; 
*
1024:  MOVLW  53
1025:  BCF    03.5
1026:  MOVWF  2F
1027:  MOVLW  49
1028:  MOVWF  30
1029:  MOVLW  43
102A:  MOVWF  31
102B:  MOVLW  41
102C:  MOVWF  32
102D:  MOVLW  4B
102E:  MOVWF  33
102F:  MOVLW  4C
1030:  MOVWF  34
1031:  MOVLW  49
1032:  MOVWF  35
1033:  MOVLW  4B
1034:  MOVWF  36
1035:  MOVLW  3D
1036:  MOVWF  37
1037:  MOVLW  30
1038:  MOVWF  38
1039:  MOVWF  39
103A:  MOVLW  2E
103B:  MOVWF  3A
103C:  MOVLW  30
103D:  MOVWF  3B
103E:  MOVLW  20
103F:  MOVWF  3C
1040:  MOVLW  43
1041:  MOVWF  3D
1042:  CLRF   3E
.................... char message2[] = "NEM     =00.0 %"; 
1043:  MOVLW  4E
1044:  MOVWF  3F
1045:  MOVLW  45
1046:  MOVWF  40
1047:  MOVLW  4D
1048:  MOVWF  41
1049:  MOVLW  20
104A:  MOVWF  42
104B:  MOVWF  43
104C:  MOVWF  44
104D:  MOVWF  45
104E:  MOVWF  46
104F:  MOVLW  3D
1050:  MOVWF  47
1051:  MOVLW  30
1052:  MOVWF  48
1053:  MOVWF  49
1054:  MOVLW  2E
1055:  MOVWF  4A
1056:  MOVLW  30
1057:  MOVWF  4B
1058:  MOVLW  20
1059:  MOVWF  4C
105A:  MOVLW  25
105B:  MOVWF  4D
105C:  CLRF   4E
....................  
.................... unsigned int8 T_byte1, T_byte2, RH_byte1, RH_byte2, CheckSum ; 
....................  
....................  
.................... void start_signal(){ 
....................   output_drive(DHT11_PIN);    // configure connection pin as output 
*
09B1:  BSF    03.5
09B2:  BCF    06.4
....................   output_low(DHT11_PIN);      // connection pin output low 
09B3:  BCF    06.4
09B4:  BCF    03.5
09B5:  BCF    06.4
....................   delay_ms(25); 
09B6:  MOVLW  19
09B7:  MOVWF  65
....................   output_high(DHT11_PIN);     // connection pin output high 
*
09CB:  BSF    03.5
09CC:  BCF    06.4
09CD:  BCF    03.5
09CE:  BSF    06.4
....................   delay_us(30); 
09CF:  MOVLW  13
09D0:  MOVWF  77
09D1:  DECFSZ 77,F
09D2:  GOTO   1D1
09D3:  GOTO   1D4
....................   output_float(DHT11_PIN);    // configure connection pin as input 
09D4:  BSF    03.5
09D5:  BSF    06.4
09D6:  BCF    03.5
09D7:  BCF    0A.3
09D8:  BSF    0A.4
09D9:  GOTO   2CD (RETURN)
.................... } 
.................... short check_response(){ 
....................   delay_us(40); 
09DA:  MOVLW  1A
09DB:  MOVWF  77
09DC:  DECFSZ 77,F
09DD:  GOTO   1DC
09DE:  NOP
....................   if(!input(DHT11_PIN)){      // read and test if connection pin is low 
09DF:  BSF    03.5
09E0:  BSF    06.4
09E1:  BCF    03.5
09E2:  BTFSC  06.4
09E3:  GOTO   1F7
....................     delay_us(80); 
09E4:  MOVLW  34
09E5:  MOVWF  77
09E6:  DECFSZ 77,F
09E7:  GOTO   1E6
09E8:  GOTO   1E9
09E9:  NOP
....................     if(input(DHT11_PIN)){     // read and test if connection pin is high 
09EA:  BSF    03.5
09EB:  BSF    06.4
09EC:  BCF    03.5
09ED:  BTFSS  06.4
09EE:  GOTO   1F7
....................       delay_us(50); 
09EF:  MOVLW  20
09F0:  MOVWF  77
09F1:  DECFSZ 77,F
09F2:  GOTO   1F1
09F3:  GOTO   1F4
09F4:  NOP
....................       return 1; 
09F5:  MOVLW  01
09F6:  MOVWF  78
....................     } 
....................   } 
09F7:  BCF    0A.3
09F8:  BSF    0A.4
09F9:  GOTO   2D2 (RETURN)
.................... } 
.................... unsigned int8 Read_Data(){ 
09FA:  CLRF   67
....................   unsigned int8 i, k, _data = 0;        // k is used to count 1 bit reading duration 
....................   if(Time_out) 
09FB:  BTFSS  2E.0
....................     break; 
....................   for(i = 0; i < 8; i++){ 
09FC:  CLRF   65
09FD:  MOVF   65,W
09FE:  SUBLW  07
09FF:  BTFSS  03.0
0A00:  GOTO   24A
....................     k = 0; 
0A01:  CLRF   66
....................     while(!input(DHT11_PIN)){           // Wait until DHT11 pin get raised 
0A02:  BSF    03.5
0A03:  BSF    06.4
0A04:  BCF    03.5
0A05:  BTFSC  06.4
0A06:  GOTO   210
....................       k++; 
0A07:  INCF   66,F
....................       if(k > 100){ 
0A08:  MOVF   66,W
0A09:  SUBLW  64
0A0A:  BTFSC  03.0
0A0B:  GOTO   20E
....................         Time_out = 1; 
0A0C:  BSF    2E.0
....................         break; 
0A0D:  GOTO   210
....................       } 
....................       delay_us(1); 
0A0E:  GOTO   20F
0A0F:  GOTO   202
....................     } 
....................     delay_us(30); 
0A10:  MOVLW  13
0A11:  MOVWF  77
0A12:  DECFSZ 77,F
0A13:  GOTO   212
0A14:  GOTO   215
....................     if(!input(DHT11_PIN)) 
0A15:  BSF    03.5
0A16:  BSF    06.4
0A17:  BCF    03.5
0A18:  BTFSC  06.4
0A19:  GOTO   22B
....................       bit_clear(_data, (7 - i));        // Clear bit (7 - i) 
0A1A:  MOVF   65,W
0A1B:  SUBLW  07
0A1C:  MOVWF  68
0A1D:  MOVLW  01
0A1E:  MOVWF  77
0A1F:  MOVF   68,W
0A20:  MOVWF  78
0A21:  BTFSC  03.2
0A22:  GOTO   227
0A23:  BCF    03.0
0A24:  RLF    77,F
0A25:  DECFSZ 78,F
0A26:  GOTO   223
0A27:  MOVF   77,W
0A28:  XORLW  FF
0A29:  ANDWF  67,F
0A2A:  GOTO   248
....................     else{ 
....................       bit_set(_data, (7 - i));          // Set bit (7 - i) 
0A2B:  MOVF   65,W
0A2C:  SUBLW  07
0A2D:  MOVWF  68
0A2E:  MOVLW  01
0A2F:  MOVWF  77
0A30:  MOVF   68,W
0A31:  MOVWF  78
0A32:  BTFSC  03.2
0A33:  GOTO   238
0A34:  BCF    03.0
0A35:  RLF    77,F
0A36:  DECFSZ 78,F
0A37:  GOTO   234
0A38:  MOVF   77,W
0A39:  IORWF  67,F
....................       while(input(DHT11_PIN)){          // Wait until DHT11 pin goes low 
0A3A:  BSF    03.5
0A3B:  BSF    06.4
0A3C:  BCF    03.5
0A3D:  BTFSS  06.4
0A3E:  GOTO   248
....................         k++; 
0A3F:  INCF   66,F
....................         if(k > 100){ 
0A40:  MOVF   66,W
0A41:  SUBLW  64
0A42:  BTFSC  03.0
0A43:  GOTO   246
....................         Time_out = 1; 
0A44:  BSF    2E.0
....................         break; 
0A45:  GOTO   248
....................       } 
....................       delay_us(1);} 
0A46:  GOTO   247
0A47:  GOTO   23A
....................     } 
0A48:  INCF   65,F
0A49:  GOTO   1FD
....................   } 
....................   return _data; 
0A4A:  MOVF   67,W
0A4B:  MOVWF  78
0A4C:  RETURN
.................... } 
....................  
....................  
.................... #use fast_io(B) 
.................... #use fast_io(C) 
....................  
.................... #use delay(clock = 8MHz) 
*
0771:  MOVLW  66
0772:  MOVWF  04
0773:  BCF    03.7
0774:  MOVF   00,W
0775:  BTFSC  03.2
0776:  GOTO   784
0777:  MOVLW  02
0778:  MOVWF  78
0779:  CLRF   77
077A:  DECFSZ 77,F
077B:  GOTO   77A
077C:  DECFSZ 78,F
077D:  GOTO   779
077E:  MOVLW  97
077F:  MOVWF  77
0780:  DECFSZ 77,F
0781:  GOTO   780
0782:  DECFSZ 00,F
0783:  GOTO   777
0784:  RETURN
....................  
.................... #use rs232(baud=9600, xmit=pin_c6, rcv = pin_c7 , parity=N, stop=1 ) 
.................... //#use rs232(baud=900, parity=N, xmit=PIN_C6, rcv=PIN_C7, bits=8, Stream=RF) 
....................  
.................... // timer 
.................... int sayac = 0, saniye = 0; 
....................  
.................... char gelenVeri; 
....................  
.................... char x = 223; 
.................... char yuzde = 37; 
....................  
.................... // bitki : 0 yok , 1 = gul , 2 = marul , 3 = cilek , sifir = 0 
.................... char bitki  = '0'; 
.................... char durum1 = '0'; 
.................... char durum2 = '0'; 
.................... char durum3 = '0'; 
.................... char seriportON_OFF = '0'; 
....................  
.................... // Degiskenlerimiz.. 
.................... int toprakNem = 0; 
.................... int suSeviye = 0; 
.................... int ldr = 0; 
.................... int toprakNemError = 0; 
.................... int fanNem = 0; // Fan'i kontrol eder deger  Ve Hava Nem 
.................... int fanSicaklik = 0; 
....................  
....................  /* 
....................     if     (gelenVeri == 'g') bitki = 1; 
....................    else if(gelenVeri == 'm') bitki = 2; 
....................    else if(gelenVeri == 'c') bitki = 3; 
....................    else if(gelenVeri == 's') bitki = 0; 
....................    */ 
....................     
.................... #int_rda // veri gelince calisan kesme 
.................... void kesme() 
.................... { 
....................    gelenVeri = getch(); 
*
0040:  BTFSS  0C.5
0041:  GOTO   040
0042:  MOVF   1A,W
0043:  MOVWF  56
....................     
....................    if     (gelenVeri == 'g') bitki = '1'; 
0044:  MOVF   56,W
0045:  SUBLW  67
0046:  BTFSS  03.2
0047:  GOTO   04B
0048:  MOVLW  31
0049:  MOVWF  59
004A:  GOTO   064
....................    else if(gelenVeri == 'm') bitki = '2'; 
004B:  MOVF   56,W
004C:  SUBLW  6D
004D:  BTFSS  03.2
004E:  GOTO   052
004F:  MOVLW  32
0050:  MOVWF  59
0051:  GOTO   064
....................    else if(gelenVeri == 'c') bitki = '3'; 
0052:  MOVF   56,W
0053:  SUBLW  63
0054:  BTFSS  03.2
0055:  GOTO   059
0056:  MOVLW  33
0057:  MOVWF  59
0058:  GOTO   064
....................    else if(gelenVeri == 's') // SIFIRLAMA 
0059:  MOVF   56,W
005A:  SUBLW  73
005B:  BTFSS  03.2
005C:  GOTO   064
....................    { 
....................    bitki  = '0'; 
005D:  MOVLW  30
005E:  MOVWF  59
....................    durum1 = '0'; 
005F:  MOVWF  5A
....................    durum2 = '0'; 
0060:  MOVWF  5B
....................    durum3 = '0'; 
0061:  MOVWF  5C
....................    seriportON_OFF = '0'; 
0062:  MOVWF  5D
....................    saniye  = 0 ; 
0063:  CLRF   55
....................    } 
....................    if     (gelenVeri == 't') durum1 = '0'; 
0064:  MOVF   56,W
0065:  SUBLW  74
0066:  BTFSS  03.2
0067:  GOTO   06B
0068:  MOVLW  30
0069:  MOVWF  5A
006A:  GOTO   071
....................    else if(gelenVeri == 'y') durum1 = '1'; 
006B:  MOVF   56,W
006C:  SUBLW  79
006D:  BTFSS  03.2
006E:  GOTO   071
006F:  MOVLW  31
0070:  MOVWF  5A
....................     
....................    if     (gelenVeri == 'u') durum2 = '0'; 
0071:  MOVF   56,W
0072:  SUBLW  75
0073:  BTFSS  03.2
0074:  GOTO   078
0075:  MOVLW  30
0076:  MOVWF  5B
0077:  GOTO   07E
....................    else if(gelenVeri == 'i') durum2 = '1'; 
0078:  MOVF   56,W
0079:  SUBLW  69
007A:  BTFSS  03.2
007B:  GOTO   07E
007C:  MOVLW  31
007D:  MOVWF  5B
....................     
....................    if     (gelenVeri == 'b') durum3 = '0'; 
007E:  MOVF   56,W
007F:  SUBLW  62
0080:  BTFSS  03.2
0081:  GOTO   085
0082:  MOVLW  30
0083:  MOVWF  5C
0084:  GOTO   08B
....................    else if(gelenVeri == 'n') durum3 = '1'; 
0085:  MOVF   56,W
0086:  SUBLW  6E
0087:  BTFSS  03.2
0088:  GOTO   08B
0089:  MOVLW  31
008A:  MOVWF  5C
....................     
....................    if     (gelenVeri == 'x') seriportON_OFF = '0'; 
008B:  MOVF   56,W
008C:  SUBLW  78
008D:  BTFSS  03.2
008E:  GOTO   092
008F:  MOVLW  30
0090:  MOVWF  5D
0091:  GOTO   098
....................    else if(gelenVeri == 'w') seriportON_OFF = '1'; 
0092:  MOVF   56,W
0093:  SUBLW  77
0094:  BTFSS  03.2
0095:  GOTO   098
0096:  MOVLW  31
0097:  MOVWF  5D
....................     
....................     
....................     
....................    write_eeprom(0,bitki); 
0098:  MOVF   0B,W
0099:  MOVWF  77
009A:  BCF    0B.7
009B:  BSF    03.6
009C:  CLRF   0D
009D:  BCF    03.6
009E:  MOVF   59,W
009F:  BSF    03.6
00A0:  MOVWF  0C
00A1:  BSF    03.5
00A2:  BCF    0C.7
00A3:  BSF    0C.2
00A4:  MOVLW  55
00A5:  MOVWF  0D
00A6:  MOVLW  AA
00A7:  MOVWF  0D
00A8:  BSF    0C.1
00A9:  BTFSC  0C.1
00AA:  GOTO   0A9
00AB:  BCF    0C.2
00AC:  MOVF   77,W
00AD:  BCF    03.5
00AE:  BCF    03.6
00AF:  IORWF  0B,F
....................    write_eeprom(1,durum1); 
00B0:  MOVF   0B,W
00B1:  MOVWF  77
00B2:  BCF    0B.7
00B3:  MOVLW  01
00B4:  BSF    03.6
00B5:  MOVWF  0D
00B6:  BCF    03.6
00B7:  MOVF   5A,W
00B8:  BSF    03.6
00B9:  MOVWF  0C
00BA:  BSF    03.5
00BB:  BCF    0C.7
00BC:  BSF    0C.2
00BD:  MOVLW  55
00BE:  MOVWF  0D
00BF:  MOVLW  AA
00C0:  MOVWF  0D
00C1:  BSF    0C.1
00C2:  BTFSC  0C.1
00C3:  GOTO   0C2
00C4:  BCF    0C.2
00C5:  MOVF   77,W
00C6:  BCF    03.5
00C7:  BCF    03.6
00C8:  IORWF  0B,F
....................    write_eeprom(2,durum2); 
00C9:  MOVF   0B,W
00CA:  MOVWF  77
00CB:  BCF    0B.7
00CC:  MOVLW  02
00CD:  BSF    03.6
00CE:  MOVWF  0D
00CF:  BCF    03.6
00D0:  MOVF   5B,W
00D1:  BSF    03.6
00D2:  MOVWF  0C
00D3:  BSF    03.5
00D4:  BCF    0C.7
00D5:  BSF    0C.2
00D6:  MOVLW  55
00D7:  MOVWF  0D
00D8:  MOVLW  AA
00D9:  MOVWF  0D
00DA:  BSF    0C.1
00DB:  BTFSC  0C.1
00DC:  GOTO   0DB
00DD:  BCF    0C.2
00DE:  MOVF   77,W
00DF:  BCF    03.5
00E0:  BCF    03.6
00E1:  IORWF  0B,F
....................    write_eeprom(3,durum3); 
00E2:  MOVF   0B,W
00E3:  MOVWF  77
00E4:  BCF    0B.7
00E5:  MOVLW  03
00E6:  BSF    03.6
00E7:  MOVWF  0D
00E8:  BCF    03.6
00E9:  MOVF   5C,W
00EA:  BSF    03.6
00EB:  MOVWF  0C
00EC:  BSF    03.5
00ED:  BCF    0C.7
00EE:  BSF    0C.2
00EF:  MOVLW  55
00F0:  MOVWF  0D
00F1:  MOVLW  AA
00F2:  MOVWF  0D
00F3:  BSF    0C.1
00F4:  BTFSC  0C.1
00F5:  GOTO   0F4
00F6:  BCF    0C.2
00F7:  MOVF   77,W
00F8:  BCF    03.5
00F9:  BCF    03.6
00FA:  IORWF  0B,F
....................     
....................     
.................... } 
....................  
....................  
....................  
00FB:  BCF    0C.5
00FC:  BCF    0A.3
00FD:  BCF    0A.4
00FE:  GOTO   021
.................... #int_TIMER0 
.................... void timer0_kesmesi() { 
....................    if(++sayac == 61)    // timer0 61 kez ta?t?ysa 
*
041B:  INCF   54,F
041C:  MOVF   54,W
041D:  SUBLW  3D
041E:  BTFSS  03.2
041F:  GOTO   4EF
....................    {                   // 61 x 16.3 ms = 1 sn s?re ge?mi?tir 
....................    if(bitki != '0') 
0420:  MOVF   59,W
0421:  SUBLW  30
0422:  BTFSS  03.2
....................       saniye++; 
0423:  INCF   55,F
....................        
....................       // Seri portun Acilmesi 
....................           
....................          if(seriportON_OFF == '1') 
0424:  MOVF   5D,W
0425:  SUBLW  31
0426:  BTFSS  03.2
0427:  GOTO   4EF
....................          { 
....................              
....................             printf("Su Seviye: %c%d\n",yuzde, suSeviye); 
0428:  MOVLW  F3
0429:  BSF    03.6
042A:  MOVWF  0D
042B:  MOVLW  04
042C:  MOVWF  0F
042D:  BCF    03.0
042E:  MOVLW  0B
042F:  BSF    03.5
0430:  BCF    03.6
0431:  MOVWF  2D
0432:  BCF    03.5
0433:  CALL   0FF
0434:  MOVF   58,W
0435:  BTFSS  0C.4
0436:  GOTO   435
0437:  MOVWF  19
0438:  MOVF   5F,W
0439:  BSF    03.5
043A:  MOVWF  2D
043B:  MOVLW  18
043C:  MOVWF  2E
043D:  BCF    03.5
043E:  CALL   184
043F:  MOVLW  0A
0440:  BTFSS  0C.4
0441:  GOTO   440
0442:  MOVWF  19
....................             printf("Toprak -------"); 
0443:  MOVLW  FC
0444:  BSF    03.6
0445:  MOVWF  0D
0446:  MOVLW  04
0447:  MOVWF  0F
0448:  BCF    03.6
0449:  CALL   1EB
....................             printf("Nem      :%c%d\n",yuzde, toprakNem); 
044A:  MOVLW  04
044B:  BSF    03.6
044C:  MOVWF  0D
044D:  MOVLW  05
044E:  MOVWF  0F
044F:  BCF    03.0
0450:  MOVLW  0A
0451:  BSF    03.5
0452:  BCF    03.6
0453:  MOVWF  2D
0454:  BCF    03.5
0455:  CALL   0FF
0456:  MOVF   58,W
0457:  BTFSS  0C.4
0458:  GOTO   457
0459:  MOVWF  19
045A:  MOVF   5E,W
045B:  BSF    03.5
045C:  MOVWF  2D
045D:  MOVLW  18
045E:  MOVWF  2E
045F:  BCF    03.5
0460:  CALL   184
0461:  MOVLW  0A
0462:  BTFSS  0C.4
0463:  GOTO   462
0464:  MOVWF  19
....................             printf("Sicaklik:%fC ",temp); 
0465:  MOVLW  0C
0466:  BSF    03.6
0467:  MOVWF  0D
0468:  MOVLW  05
0469:  MOVWF  0F
046A:  BCF    03.0
046B:  MOVLW  09
046C:  BSF    03.5
046D:  BCF    03.6
046E:  MOVWF  2D
046F:  BCF    03.5
0470:  CALL   0FF
0471:  MOVLW  89
0472:  MOVWF  04
0473:  MOVF   2D,W
0474:  BSF    03.5
0475:  MOVWF  30
0476:  BCF    03.5
0477:  MOVF   2C,W
0478:  BSF    03.5
0479:  MOVWF  2F
047A:  BCF    03.5
047B:  MOVF   2B,W
047C:  BSF    03.5
047D:  MOVWF  2E
047E:  BCF    03.5
047F:  MOVF   2A,W
0480:  BSF    03.5
0481:  MOVWF  2D
0482:  MOVLW  02
0483:  MOVWF  31
0484:  BCF    03.5
0485:  GOTO   33C
0486:  MOVLW  43
0487:  BTFSS  0C.4
0488:  GOTO   487
0489:  MOVWF  19
048A:  MOVLW  20
048B:  BTFSS  0C.4
048C:  GOTO   48B
048D:  MOVWF  19
....................              
....................             printf("----------------"); 
048E:  MOVLW  13
048F:  BSF    03.6
0490:  MOVWF  0D
0491:  MOVLW  05
0492:  MOVWF  0F
0493:  BCF    03.6
0494:  CALL   1EB
....................             printf("Hava ---------"); 
0495:  MOVLW  1C
0496:  BSF    03.6
0497:  MOVWF  0D
0498:  MOVLW  05
0499:  MOVWF  0F
049A:  BCF    03.6
049B:  CALL   1EB
....................             printf("Nem      :%c%d\n",yuzde, fanNem); 
049C:  MOVLW  24
049D:  BSF    03.6
049E:  MOVWF  0D
049F:  MOVLW  05
04A0:  MOVWF  0F
04A1:  BCF    03.0
04A2:  MOVLW  0A
04A3:  BSF    03.5
04A4:  BCF    03.6
04A5:  MOVWF  2D
04A6:  BCF    03.5
04A7:  CALL   0FF
04A8:  MOVF   58,W
04A9:  BTFSS  0C.4
04AA:  GOTO   4A9
04AB:  MOVWF  19
04AC:  MOVF   62,W
04AD:  BSF    03.5
04AE:  MOVWF  2D
04AF:  MOVLW  18
04B0:  MOVWF  2E
04B1:  BCF    03.5
04B2:  CALL   184
04B3:  MOVLW  0A
04B4:  BTFSS  0C.4
04B5:  GOTO   4B4
04B6:  MOVWF  19
....................             printf("Sicaklik:%dC", fanSicaklik); 
04B7:  MOVLW  2C
04B8:  BSF    03.6
04B9:  MOVWF  0D
04BA:  MOVLW  05
04BB:  MOVWF  0F
04BC:  BCF    03.0
04BD:  MOVLW  09
04BE:  BSF    03.5
04BF:  BCF    03.6
04C0:  MOVWF  2D
04C1:  BCF    03.5
04C2:  CALL   0FF
04C3:  MOVF   63,W
04C4:  BSF    03.5
04C5:  MOVWF  2D
04C6:  MOVLW  18
04C7:  MOVWF  2E
04C8:  BCF    03.5
04C9:  CALL   184
04CA:  MOVLW  43
04CB:  BTFSS  0C.4
04CC:  GOTO   4CB
04CD:  MOVWF  19
....................             printf("----------------"); 
04CE:  MOVLW  33
04CF:  BSF    03.6
04D0:  MOVWF  0D
04D1:  MOVLW  05
04D2:  MOVWF  0F
04D3:  BCF    03.6
04D4:  CALL   1EB
....................             printf("Isik Siddeti: %d", ldr); 
04D5:  MOVLW  3C
04D6:  BSF    03.6
04D7:  MOVWF  0D
04D8:  MOVLW  05
04D9:  MOVWF  0F
04DA:  BCF    03.0
04DB:  MOVLW  0E
04DC:  BSF    03.5
04DD:  BCF    03.6
04DE:  MOVWF  2D
04DF:  BCF    03.5
04E0:  CALL   0FF
04E1:  MOVF   60,W
04E2:  BSF    03.5
04E3:  MOVWF  2D
04E4:  MOVLW  18
04E5:  MOVWF  2E
04E6:  BCF    03.5
04E7:  CALL   184
....................             printf("--------------"); 
04E8:  MOVLW  45
04E9:  BSF    03.6
04EA:  MOVWF  0D
04EB:  MOVLW  05
04EC:  MOVWF  0F
04ED:  BCF    03.6
04EE:  CALL   1EB
....................           
....................          } 
....................    }   
04EF:  BCF    0B.2
04F0:  BCF    0A.3
04F1:  BCF    0A.4
04F2:  GOTO   021
.................... } 
....................  
....................  
.................... void main() 
*
1000:  MOVLW  0C
1001:  BSF    03.5
1002:  MOVWF  19
1003:  MOVLW  A2
1004:  MOVWF  18
1005:  MOVLW  90
1006:  BCF    03.5
1007:  MOVWF  18
1008:  CLRF   54
1009:  CLRF   55
100A:  MOVLW  DF
100B:  MOVWF  57
100C:  MOVLW  25
100D:  MOVWF  58
100E:  MOVLW  30
100F:  MOVWF  59
1010:  MOVWF  5A
1011:  MOVWF  5B
1012:  MOVWF  5C
1013:  MOVWF  5D
1014:  CLRF   5E
1015:  CLRF   5F
1016:  CLRF   60
1017:  CLRF   61
1018:  CLRF   62
1019:  CLRF   63
101A:  BSF    03.5
101B:  BSF    1F.0
101C:  BSF    1F.1
101D:  BSF    1F.2
101E:  BCF    1F.3
101F:  MOVLW  07
1020:  MOVWF  1C
1021:  BCF    03.7
1022:  MOVLW  1F
1023:  ANDWF  03,F
.................... { 
....................        
....................    //ADC 
....................    setup_adc(adc_clock_div_32);  
*
105D:  BSF    03.5
105E:  BCF    1F.6
105F:  BCF    03.5
1060:  BCF    1F.6
1061:  BSF    1F.7
1062:  BSF    03.5
1063:  BSF    1F.7
1064:  BCF    03.5
1065:  BSF    1F.0
....................    setup_adc_ports(AN0_AN1_AN2_AN3_AN4);  
1066:  BSF    03.5
1067:  BCF    1F.0
1068:  BSF    1F.1
1069:  BCF    1F.2
106A:  BCF    1F.3
....................  
....................     
....................     
....................    // Bitki Secim icin -- 
....................     
....................    set_tris_c(0xF8); 
106B:  MOVLW  F8
106C:  MOVWF  07
....................    set_tris_b(0xF2); 
106D:  MOVLW  F2
106E:  MOVWF  06
....................     
....................    output_c(0); 
106F:  BCF    03.5
1070:  CLRF   07
....................    output_b(0); 
1071:  CLRF   06
....................     // timer 
....................    setup_timer_0(RTCC_INTERNAL|RTCC_DIV_32|RTCC_8_bit);      //16.3 ms overflow 
1072:  BSF    03.5
1073:  MOVF   01,W
1074:  ANDLW  C0
1075:  IORLW  04
1076:  MOVWF  01
....................    enable_interrupts(INT_TIMER0); //kesme aktif 
1077:  BCF    03.5
1078:  BSF    0B.5
....................     
....................     
....................    // rs232 icin 
....................    enable_interrupts(int_rda); // int_rda kesmesi aaktif 
1079:  BSF    03.5
107A:  BSF    0C.5
....................    enable_interrupts(GLOBAL); 
107B:  MOVLW  C0
107C:  BCF    03.5
107D:  IORWF  0B,F
....................  
....................     
....................      
....................    lcd_init(); 
107E:  BCF    0A.4
107F:  GOTO   6A5
1080:  BSF    0A.4
....................    lcd_putc('\f');                                 
1081:  MOVLW  0C
1082:  MOVWF  72
1083:  BCF    0A.4
1084:  CALL   702
1085:  BSF    0A.4
....................    lcd_gotoxy(1, 1); 
1086:  MOVLW  01
1087:  MOVWF  73
1088:  MOVWF  74
1089:  BCF    0A.4
108A:  CALL   6DF
108B:  BSF    0A.4
....................     
....................    printf(lcd_putc, "  **  SERA  **  "); 
108C:  MOVLW  4D
108D:  BSF    03.6
108E:  MOVWF  0D
108F:  MOVLW  05
1090:  MOVWF  0F
1091:  BCF    0A.4
1092:  BCF    03.6
1093:  CALL   726
1094:  BSF    0A.4
....................    printf(lcd_putc, "\n   OTOMASYONU   "); 
1095:  MOVLW  56
1096:  BSF    03.6
1097:  MOVWF  0D
1098:  MOVLW  05
1099:  MOVWF  0F
109A:  BCF    0A.4
109B:  BCF    03.6
109C:  CALL   726
109D:  BSF    0A.4
....................    delay_ms(1000); 
109E:  MOVLW  04
109F:  MOVWF  65
10A0:  MOVLW  FA
10A1:  MOVWF  66
10A2:  BCF    0A.4
10A3:  CALL   771
10A4:  BSF    0A.4
10A5:  DECFSZ 65,F
10A6:  GOTO   0A0
....................     
....................    printf(lcd_putc,"\f"); 
10A7:  MOVLW  0C
10A8:  MOVWF  72
10A9:  BCF    0A.4
10AA:  CALL   702
10AB:  BSF    0A.4
....................    printf(lcd_putc, "Basliyor..."); 
10AC:  MOVLW  5F
10AD:  BSF    03.6
10AE:  MOVWF  0D
10AF:  MOVLW  05
10B0:  MOVWF  0F
10B1:  BCF    0A.4
10B2:  BCF    03.6
10B3:  CALL   726
10B4:  BSF    0A.4
....................    
....................   // ROM deki verilern ï¿½ekilmesi 
....................    bitki  = read_eeprom(0); 
10B5:  BSF    03.6
10B6:  CLRF   0D
10B7:  BSF    03.5
10B8:  BCF    0C.7
10B9:  BSF    0C.0
10BA:  BCF    03.5
10BB:  MOVF   0C,W
10BC:  BCF    03.6
10BD:  MOVWF  59
....................    durum1 = read_eeprom(1); 
10BE:  MOVLW  01
10BF:  BSF    03.6
10C0:  MOVWF  0D
10C1:  BSF    03.5
10C2:  BCF    0C.7
10C3:  BSF    0C.0
10C4:  BCF    03.5
10C5:  MOVF   0C,W
10C6:  BCF    03.6
10C7:  MOVWF  5A
....................    durum2 = read_eeprom(2); 
10C8:  MOVLW  02
10C9:  BSF    03.6
10CA:  MOVWF  0D
10CB:  BSF    03.5
10CC:  BCF    0C.7
10CD:  BSF    0C.0
10CE:  BCF    03.5
10CF:  MOVF   0C,W
10D0:  BCF    03.6
10D1:  MOVWF  5B
....................    durum3 = read_eeprom(3); 
10D2:  MOVLW  03
10D3:  BSF    03.6
10D4:  MOVWF  0D
10D5:  BSF    03.5
10D6:  BCF    0C.7
10D7:  BSF    0C.0
10D8:  BCF    03.5
10D9:  MOVF   0C,W
10DA:  BCF    03.6
10DB:  MOVWF  5C
....................    printf(lcd_putc,"\f"); 
10DC:  MOVLW  0C
10DD:  MOVWF  72
10DE:  BCF    0A.4
10DF:  CALL   702
10E0:  BSF    0A.4
....................    printf(lcd_putc, "Basliyor1ee..."); 
10E1:  MOVLW  65
10E2:  BSF    03.6
10E3:  MOVWF  0D
10E4:  MOVLW  05
10E5:  MOVWF  0F
10E6:  BCF    0A.4
10E7:  BCF    03.6
10E8:  CALL   726
10E9:  BSF    0A.4
....................     
....................    int i = 0; 
10EA:  CLRF   64
....................    // bitkinin saate bildirilmesi 
....................    if(bitki == '1') 
10EB:  MOVF   59,W
10EC:  SUBLW  31
10ED:  BTFSS  03.2
10EE:  GOTO   104
....................       { 
....................           
....................          delay_ms(400); 
10EF:  MOVLW  02
10F0:  MOVWF  65
10F1:  MOVLW  C8
10F2:  MOVWF  66
10F3:  BCF    0A.4
10F4:  CALL   771
10F5:  BSF    0A.4
10F6:  DECFSZ 65,F
10F7:  GOTO   0F1
....................          output_high(pin_c0); 
10F8:  BSF    07.0
....................          delay_ms(400); 
10F9:  MOVLW  02
10FA:  MOVWF  65
10FB:  MOVLW  C8
10FC:  MOVWF  66
10FD:  BCF    0A.4
10FE:  CALL   771
10FF:  BSF    0A.4
1100:  DECFSZ 65,F
1101:  GOTO   0FB
....................          output_low(pin_c0); 
1102:  BCF    07.0
....................       } 
1103:  GOTO   155
....................       else if(bitki == '2') 
1104:  MOVF   59,W
1105:  SUBLW  32
1106:  BTFSS  03.2
1107:  GOTO   12D
....................       { 
....................          for (i=0;i<2;i++) 
1108:  CLRF   64
1109:  MOVF   64,W
110A:  SUBLW  01
110B:  BTFSS  03.0
110C:  GOTO   12C
....................          { 
....................          delay_ms(400); 
110D:  MOVLW  02
110E:  MOVWF  65
110F:  MOVLW  C8
1110:  MOVWF  66
1111:  BCF    0A.4
1112:  CALL   771
1113:  BSF    0A.4
1114:  DECFSZ 65,F
1115:  GOTO   10F
....................          output_high(pin_c0); 
1116:  BSF    07.0
....................          delay_ms(400); 
1117:  MOVLW  02
1118:  MOVWF  65
1119:  MOVLW  C8
111A:  MOVWF  66
111B:  BCF    0A.4
111C:  CALL   771
111D:  BSF    0A.4
111E:  DECFSZ 65,F
111F:  GOTO   119
....................          output_low(pin_c0); 
1120:  BCF    07.0
....................          delay_ms(400); 
1121:  MOVLW  02
1122:  MOVWF  65
1123:  MOVLW  C8
1124:  MOVWF  66
1125:  BCF    0A.4
1126:  CALL   771
1127:  BSF    0A.4
1128:  DECFSZ 65,F
1129:  GOTO   123
112A:  INCF   64,F
112B:  GOTO   109
....................          } 
....................       } 
112C:  GOTO   155
....................       else if(bitki == '3') 
112D:  MOVF   59,W
112E:  SUBLW  33
112F:  BTFSS  03.2
1130:  GOTO   155
....................       { 
....................          for (i=0;i<3;i++) 
1131:  CLRF   64
1132:  MOVF   64,W
1133:  SUBLW  02
1134:  BTFSS  03.0
1135:  GOTO   155
....................          { 
....................          delay_ms(400); 
1136:  MOVLW  02
1137:  MOVWF  65
1138:  MOVLW  C8
1139:  MOVWF  66
113A:  BCF    0A.4
113B:  CALL   771
113C:  BSF    0A.4
113D:  DECFSZ 65,F
113E:  GOTO   138
....................          output_high(pin_c0); 
113F:  BSF    07.0
....................          delay_ms(400); 
1140:  MOVLW  02
1141:  MOVWF  65
1142:  MOVLW  C8
1143:  MOVWF  66
1144:  BCF    0A.4
1145:  CALL   771
1146:  BSF    0A.4
1147:  DECFSZ 65,F
1148:  GOTO   142
....................          output_low(pin_c0); 
1149:  BCF    07.0
....................          delay_ms(400); 
114A:  MOVLW  02
114B:  MOVWF  65
114C:  MOVLW  C8
114D:  MOVWF  66
114E:  BCF    0A.4
114F:  CALL   771
1150:  BSF    0A.4
1151:  DECFSZ 65,F
1152:  GOTO   14C
1153:  INCF   64,F
1154:  GOTO   132
....................          } 
....................       } 
....................        
....................        
....................       //  Durumlarin Gonderilmesi 
....................       if(durum3 == '1') 
1155:  MOVF   5C,W
1156:  SUBLW  31
1157:  BTFSS  03.2
1158:  GOTO   17E
....................       { 
....................       for (i=0;i<3;i++) 
1159:  CLRF   64
115A:  MOVF   64,W
115B:  SUBLW  02
115C:  BTFSS  03.0
115D:  GOTO   17D
....................          { 
....................          delay_ms(400); 
115E:  MOVLW  02
115F:  MOVWF  65
1160:  MOVLW  C8
1161:  MOVWF  66
1162:  BCF    0A.4
1163:  CALL   771
1164:  BSF    0A.4
1165:  DECFSZ 65,F
1166:  GOTO   160
....................          output_high(pin_c1); 
1167:  BSF    07.1
....................          delay_ms(400); 
1168:  MOVLW  02
1169:  MOVWF  65
116A:  MOVLW  C8
116B:  MOVWF  66
116C:  BCF    0A.4
116D:  CALL   771
116E:  BSF    0A.4
116F:  DECFSZ 65,F
1170:  GOTO   16A
....................          output_low(pin_c1); 
1171:  BCF    07.1
....................          delay_ms(400); 
1172:  MOVLW  02
1173:  MOVWF  65
1174:  MOVLW  C8
1175:  MOVWF  66
1176:  BCF    0A.4
1177:  CALL   771
1178:  BSF    0A.4
1179:  DECFSZ 65,F
117A:  GOTO   174
117B:  INCF   64,F
117C:  GOTO   15A
....................           
....................          } 
....................       } 
117D:  GOTO   1B6
....................       else if(durum2 == '1') 
117E:  MOVF   5B,W
117F:  SUBLW  31
1180:  BTFSS  03.2
1181:  GOTO   19E
....................       { 
....................          for (i=0;i<3;i++) 
1182:  CLRF   64
1183:  MOVF   64,W
1184:  SUBLW  02
1185:  BTFSS  03.0
1186:  GOTO   19D
....................          { 
....................          delay_ms(400); 
1187:  MOVLW  02
1188:  MOVWF  65
1189:  MOVLW  C8
118A:  MOVWF  66
118B:  BCF    0A.4
118C:  CALL   771
118D:  BSF    0A.4
118E:  DECFSZ 65,F
118F:  GOTO   189
....................          output_high(pin_c1); 
1190:  BSF    07.1
....................          delay_ms(400); 
1191:  MOVLW  02
1192:  MOVWF  65
1193:  MOVLW  C8
1194:  MOVWF  66
1195:  BCF    0A.4
1196:  CALL   771
1197:  BSF    0A.4
1198:  DECFSZ 65,F
1199:  GOTO   193
....................          output_low(pin_c1); 
119A:  BCF    07.1
119B:  INCF   64,F
119C:  GOTO   183
....................           
....................          } 
....................       } 
119D:  GOTO   1B6
....................       else if(durum1 == '1') 
119E:  MOVF   5A,W
119F:  SUBLW  31
11A0:  BTFSS  03.2
11A1:  GOTO   1B6
....................       { 
....................          delay_ms(400); 
11A2:  MOVLW  02
11A3:  MOVWF  65
11A4:  MOVLW  C8
11A5:  MOVWF  66
11A6:  BCF    0A.4
11A7:  CALL   771
11A8:  BSF    0A.4
11A9:  DECFSZ 65,F
11AA:  GOTO   1A4
....................          output_high(pin_c1); 
11AB:  BSF    07.1
....................          delay_ms(400); 
11AC:  MOVLW  02
11AD:  MOVWF  65
11AE:  MOVLW  C8
11AF:  MOVWF  66
11B0:  BCF    0A.4
11B1:  CALL   771
11B2:  BSF    0A.4
11B3:  DECFSZ 65,F
11B4:  GOTO   1AE
....................          output_low(pin_c1); 
11B5:  BCF    07.1
....................       } 
....................     
....................   
....................      printf(lcd_putc,"\f"); 
11B6:  MOVLW  0C
11B7:  MOVWF  72
11B8:  BCF    0A.4
11B9:  CALL   702
11BA:  BSF    0A.4
....................    printf(lcd_putc, "Basliyor2st..."); 
11BB:  MOVLW  6D
11BC:  BSF    03.6
11BD:  MOVWF  0D
11BE:  MOVLW  05
11BF:  MOVWF  0F
11C0:  BCF    0A.4
11C1:  BCF    03.6
11C2:  CALL   726
11C3:  BSF    0A.4
....................     
....................  // Ana Dongunun Girisi 
....................  //_------ 
....................    while(TRUE) 
....................    { 
....................   
....................      
....................    // Butun sinyaller her an okunuyor 
....................     
....................       // Su Seviye 
....................       set_adc_channel(1); 
11C4:  MOVLW  08
11C5:  MOVWF  78
11C6:  MOVF   1F,W
11C7:  ANDLW  C7
11C8:  IORWF  78,W
11C9:  MOVWF  1F
....................       suSeviye =  read_adc() * 0.1; 
11CA:  BSF    1F.2
11CB:  BTFSC  1F.2
11CC:  GOTO   1CB
11CD:  MOVF   1E,W
11CE:  MOVWF  7A
11CF:  BSF    03.5
11D0:  MOVF   1E,W
11D1:  BCF    03.5
11D2:  MOVWF  65
11D3:  MOVF   1E,W
11D4:  MOVWF  66
11D5:  MOVWF  68
11D6:  MOVF   65,W
11D7:  MOVWF  67
11D8:  BCF    0A.4
11D9:  CALL   785
11DA:  BSF    0A.4
11DB:  CLRF   27
11DC:  BTFSC  0B.7
11DD:  BSF    27.7
11DE:  BCF    0B.7
11DF:  MOVF   7A,W
11E0:  BSF    03.5
11E1:  MOVWF  3D
11E2:  MOVF   79,W
11E3:  MOVWF  3C
11E4:  MOVF   78,W
11E5:  MOVWF  3B
11E6:  MOVF   77,W
11E7:  MOVWF  3A
11E8:  MOVLW  CD
11E9:  MOVWF  41
11EA:  MOVLW  CC
11EB:  MOVWF  40
11EC:  MOVLW  4C
11ED:  MOVWF  3F
11EE:  MOVLW  7B
11EF:  MOVWF  3E
11F0:  BCF    0A.4
11F1:  BCF    03.5
11F2:  CALL   253
11F3:  BSF    0A.4
11F4:  BTFSC  27.7
11F5:  BSF    0B.7
11F6:  MOVF   7A,W
11F7:  MOVWF  68
11F8:  MOVF   79,W
11F9:  MOVWF  67
11FA:  MOVF   78,W
11FB:  MOVWF  66
11FC:  MOVF   77,W
11FD:  MOVWF  65
11FE:  BCF    0A.4
11FF:  CALL   7A2
1200:  BSF    0A.4
1201:  MOVF   78,W
1202:  MOVWF  5F
....................       // Toprak Nem 
....................       set_adc_channel(0); 
1203:  MOVLW  00
1204:  MOVWF  78
1205:  MOVF   1F,W
1206:  ANDLW  C7
1207:  IORWF  78,W
1208:  MOVWF  1F
....................       toprakNem =  read_adc() * 0.1; 
1209:  BSF    1F.2
120A:  BTFSC  1F.2
120B:  GOTO   20A
120C:  MOVF   1E,W
120D:  MOVWF  7A
120E:  BSF    03.5
120F:  MOVF   1E,W
1210:  BCF    03.5
1211:  MOVWF  65
1212:  MOVF   1E,W
1213:  MOVWF  66
1214:  MOVWF  68
1215:  MOVF   65,W
1216:  MOVWF  67
1217:  BCF    0A.4
1218:  CALL   785
1219:  BSF    0A.4
121A:  CLRF   27
121B:  BTFSC  0B.7
121C:  BSF    27.7
121D:  BCF    0B.7
121E:  MOVF   7A,W
121F:  BSF    03.5
1220:  MOVWF  3D
1221:  MOVF   79,W
1222:  MOVWF  3C
1223:  MOVF   78,W
1224:  MOVWF  3B
1225:  MOVF   77,W
1226:  MOVWF  3A
1227:  MOVLW  CD
1228:  MOVWF  41
1229:  MOVLW  CC
122A:  MOVWF  40
122B:  MOVLW  4C
122C:  MOVWF  3F
122D:  MOVLW  7B
122E:  MOVWF  3E
122F:  BCF    0A.4
1230:  BCF    03.5
1231:  CALL   253
1232:  BSF    0A.4
1233:  BTFSC  27.7
1234:  BSF    0B.7
1235:  MOVF   7A,W
1236:  MOVWF  68
1237:  MOVF   79,W
1238:  MOVWF  67
1239:  MOVF   78,W
123A:  MOVWF  66
123B:  MOVF   77,W
123C:  MOVWF  65
123D:  BCF    0A.4
123E:  CALL   7A2
123F:  BSF    0A.4
1240:  MOVF   78,W
1241:  MOVWF  5E
....................       // LDR 
....................       set_adc_channel(2); 
1242:  MOVLW  10
1243:  MOVWF  78
1244:  MOVF   1F,W
1245:  ANDLW  C7
1246:  IORWF  78,W
1247:  MOVWF  1F
....................       ldr =  read_adc() * 0.1; 
1248:  BSF    1F.2
1249:  BTFSC  1F.2
124A:  GOTO   249
124B:  MOVF   1E,W
124C:  MOVWF  7A
124D:  BSF    03.5
124E:  MOVF   1E,W
124F:  BCF    03.5
1250:  MOVWF  65
1251:  MOVF   1E,W
1252:  MOVWF  66
1253:  MOVWF  68
1254:  MOVF   65,W
1255:  MOVWF  67
1256:  BCF    0A.4
1257:  CALL   785
1258:  BSF    0A.4
1259:  CLRF   27
125A:  BTFSC  0B.7
125B:  BSF    27.7
125C:  BCF    0B.7
125D:  MOVF   7A,W
125E:  BSF    03.5
125F:  MOVWF  3D
1260:  MOVF   79,W
1261:  MOVWF  3C
1262:  MOVF   78,W
1263:  MOVWF  3B
1264:  MOVF   77,W
1265:  MOVWF  3A
1266:  MOVLW  CD
1267:  MOVWF  41
1268:  MOVLW  CC
1269:  MOVWF  40
126A:  MOVLW  4C
126B:  MOVWF  3F
126C:  MOVLW  7B
126D:  MOVWF  3E
126E:  BCF    0A.4
126F:  BCF    03.5
1270:  CALL   253
1271:  BSF    0A.4
1272:  BTFSC  27.7
1273:  BSF    0B.7
1274:  MOVF   7A,W
1275:  MOVWF  68
1276:  MOVF   79,W
1277:  MOVWF  67
1278:  MOVF   78,W
1279:  MOVWF  66
127A:  MOVF   77,W
127B:  MOVWF  65
127C:  BCF    0A.4
127D:  CALL   7A2
127E:  BSF    0A.4
127F:  MOVF   78,W
1280:  MOVWF  60
....................        
....................      // toprakSicaklik 
....................       if(ds18b20_read(&raw_temp))  
1281:  CLRF   66
1282:  MOVLW  28
1283:  MOVWF  65
1284:  BCF    0A.4
1285:  BSF    0A.3
1286:  GOTO   062
1287:  BSF    0A.4
1288:  BCF    0A.3
1289:  MOVF   78,F
128A:  BTFSC  03.2
128B:  GOTO   2B9
....................      { 
....................       temp = (float)raw_temp / 16;                
128C:  MOVF   29,W
128D:  MOVWF  66
128E:  MOVF   28,W
128F:  MOVWF  65
1290:  BCF    0A.4
1291:  BSF    0A.3
1292:  GOTO   0BE
1293:  BSF    0A.4
1294:  BCF    0A.3
1295:  MOVF   7A,W
1296:  MOVWF  68
1297:  MOVF   79,W
1298:  MOVWF  67
1299:  MOVF   78,W
129A:  MOVWF  66
129B:  MOVF   77,W
129C:  MOVWF  65
129D:  MOVF   68,W
129E:  MOVWF  6C
129F:  MOVF   67,W
12A0:  MOVWF  6B
12A1:  MOVF   66,W
12A2:  MOVWF  6A
12A3:  MOVF   65,W
12A4:  MOVWF  69
12A5:  CLRF   70
12A6:  CLRF   6F
12A7:  CLRF   6E
12A8:  MOVLW  83
12A9:  MOVWF  6D
12AA:  BCF    0A.4
12AB:  BSF    0A.3
12AC:  GOTO   0E5
12AD:  BSF    0A.4
12AE:  BCF    0A.3
12AF:  MOVF   7A,W
12B0:  MOVWF  2D
12B1:  MOVF   79,W
12B2:  MOVWF  2C
12B3:  MOVF   78,W
12B4:  MOVWF  2B
12B5:  MOVF   77,W
12B6:  MOVWF  2A
....................                                
....................       toprakNemError = 0; 
12B7:  CLRF   61
....................                                   
....................       } 
12B8:  GOTO   2BB
....................       else { 
....................       toprakNemError = 1;                 
12B9:  MOVLW  01
12BA:  MOVWF  61
....................       } 
....................         printf(lcd_putc,"\f"); 
12BB:  MOVLW  0C
12BC:  MOVWF  72
12BD:  BCF    0A.4
12BE:  CALL   702
12BF:  BSF    0A.4
....................    printf(lcd_putc, "dht1r..."); 
12C0:  MOVLW  75
12C1:  BSF    03.6
12C2:  MOVWF  0D
12C3:  MOVLW  05
12C4:  MOVWF  0F
12C5:  BCF    0A.4
12C6:  BCF    03.6
12C7:  CALL   726
12C8:  BSF    0A.4
....................       // DHT11  
....................          Time_out = 0; 
12C9:  BCF    2E.0
....................          Start_signal(); 
12CA:  BCF    0A.4
12CB:  BSF    0A.3
12CC:  GOTO   1B1
12CD:  BSF    0A.4
12CE:  BCF    0A.3
....................          if(check_response()) 
12CF:  BCF    0A.4
12D0:  BSF    0A.3
12D1:  GOTO   1DA
12D2:  BSF    0A.4
12D3:  BCF    0A.3
12D4:  MOVF   78,F
12D5:  BTFSC  03.2
12D6:  GOTO   4CB
....................          {                     // Sensorden tepki varsa  
....................          RH_byte1 = Read_Data();                 // okuma RH byte1 
12D7:  BCF    0A.4
12D8:  BSF    0A.3
12D9:  CALL   1FA
12DA:  BSF    0A.4
12DB:  BCF    0A.3
12DC:  MOVF   78,W
12DD:  MOVWF  51
....................          RH_byte2 = Read_Data();                 // okuma RH byte2 
12DE:  BCF    0A.4
12DF:  BSF    0A.3
12E0:  CALL   1FA
12E1:  BSF    0A.4
12E2:  BCF    0A.3
12E3:  MOVF   78,W
12E4:  MOVWF  52
....................          T_byte1 = Read_Data();                  // okuma T byte1 
12E5:  BCF    0A.4
12E6:  BSF    0A.3
12E7:  CALL   1FA
12E8:  BSF    0A.4
12E9:  BCF    0A.3
12EA:  MOVF   78,W
12EB:  MOVWF  4F
....................          T_byte2 = Read_Data();                  // okuma T byte2 
12EC:  BCF    0A.4
12ED:  BSF    0A.3
12EE:  CALL   1FA
12EF:  BSF    0A.4
12F0:  BCF    0A.3
12F1:  MOVF   78,W
12F2:  MOVWF  50
....................          Checksum = Read_Data();                 // okuma checksum 
12F3:  BCF    0A.4
12F4:  BSF    0A.3
12F5:  CALL   1FA
12F6:  BSF    0A.4
12F7:  BCF    0A.3
12F8:  MOVF   78,W
12F9:  MOVWF  53
....................          if(Time_out) 
12FA:  BTFSS  2E.0
12FB:  GOTO   31C
....................          {   
....................             if(10 >saniye > 5 ) 
12FC:  MOVF   55,W
12FD:  SUBLW  09
12FE:  BTFSC  03.0
12FF:  GOTO   302
1300:  MOVLW  00
1301:  GOTO   303
1302:  MOVLW  01
1303:  SUBLW  05
1304:  BTFSC  03.0
1305:  GOTO   31B
....................             {      
....................                lcd_putc('\f');                       // LCD clear 
1306:  MOVLW  0C
1307:  MOVWF  72
1308:  BCF    0A.4
1309:  CALL   702
130A:  BSF    0A.4
....................                lcd_gotoxy(5, 1);                     // Go to column 5 row 1 
130B:  MOVLW  05
130C:  MOVWF  73
130D:  MOVLW  01
130E:  MOVWF  74
130F:  BCF    0A.4
1310:  CALL   6DF
1311:  BSF    0A.4
....................                lcd_putc("Time out!"); 
1312:  MOVLW  7A
1313:  BSF    03.6
1314:  MOVWF  0D
1315:  MOVLW  05
1316:  MOVWF  0F
1317:  BCF    0A.4
1318:  BCF    03.6
1319:  CALL   726
131A:  BSF    0A.4
....................             } 
....................          } 
131B:  GOTO   4CA
....................          else 
....................          { 
....................           if(CheckSum == ((RH_Byte1 + RH_Byte2 + T_Byte1 + T_Byte2) & 0xFF)) 
131C:  MOVF   52,W
131D:  ADDWF  51,W
131E:  ADDWF  4F,W
131F:  ADDWF  50,W
1320:  SUBWF  53,W
1321:  BTFSS  03.2
1322:  GOTO   4AC
1323:  CLRF   27
1324:  BTFSC  0B.7
1325:  BSF    27.7
1326:  BCF    0B.7
....................           { 
....................             message1[9]  = T_Byte1/10  + 48; 
1327:  MOVF   4F,W
1328:  BSF    03.5
1329:  MOVWF  33
132A:  MOVLW  0A
132B:  MOVWF  34
132C:  BCF    0A.4
132D:  BCF    03.5
132E:  CALL   16D
132F:  BSF    0A.4
1330:  BTFSC  27.7
1331:  BSF    0B.7
1332:  MOVLW  30
1333:  ADDWF  78,W
1334:  MOVWF  38
1335:  CLRF   27
1336:  BTFSC  0B.7
1337:  BSF    27.7
1338:  BCF    0B.7
....................             message1[10]  = T_Byte1%10  + 48; 
1339:  MOVF   4F,W
133A:  BSF    03.5
133B:  MOVWF  33
133C:  MOVLW  0A
133D:  MOVWF  34
133E:  BCF    0A.4
133F:  BCF    03.5
1340:  CALL   16D
1341:  BSF    0A.4
1342:  BTFSC  27.7
1343:  BSF    0B.7
1344:  MOVLW  30
1345:  ADDWF  77,W
1346:  MOVWF  39
1347:  CLRF   27
1348:  BTFSC  0B.7
1349:  BSF    27.7
134A:  BCF    0B.7
....................             message1[12] = T_Byte2/10  + 48; 
134B:  MOVF   50,W
134C:  BSF    03.5
134D:  MOVWF  33
134E:  MOVLW  0A
134F:  MOVWF  34
1350:  BCF    0A.4
1351:  BCF    03.5
1352:  CALL   16D
1353:  BSF    0A.4
1354:  BTFSC  27.7
1355:  BSF    0B.7
1356:  MOVLW  30
1357:  ADDWF  78,W
1358:  MOVWF  3B
1359:  CLRF   27
135A:  BTFSC  0B.7
135B:  BSF    27.7
135C:  BCF    0B.7
....................             message2[9]  = RH_Byte1/10 + 48; 
135D:  MOVF   51,W
135E:  BSF    03.5
135F:  MOVWF  33
1360:  MOVLW  0A
1361:  MOVWF  34
1362:  BCF    0A.4
1363:  BCF    03.5
1364:  CALL   16D
1365:  BSF    0A.4
1366:  BTFSC  27.7
1367:  BSF    0B.7
1368:  MOVLW  30
1369:  ADDWF  78,W
136A:  MOVWF  48
136B:  CLRF   27
136C:  BTFSC  0B.7
136D:  BSF    27.7
136E:  BCF    0B.7
....................             message2[10]  = RH_Byte1%10 + 48; 
136F:  MOVF   51,W
1370:  BSF    03.5
1371:  MOVWF  33
1372:  MOVLW  0A
1373:  MOVWF  34
1374:  BCF    0A.4
1375:  BCF    03.5
1376:  CALL   16D
1377:  BSF    0A.4
1378:  BTFSC  27.7
1379:  BSF    0B.7
137A:  MOVLW  30
137B:  ADDWF  77,W
137C:  MOVWF  49
137D:  CLRF   27
137E:  BTFSC  0B.7
137F:  BSF    27.7
1380:  BCF    0B.7
....................             message2[12] = RH_Byte2/10 + 48; 
1381:  MOVF   52,W
1382:  BSF    03.5
1383:  MOVWF  33
1384:  MOVLW  0A
1385:  MOVWF  34
1386:  BCF    0A.4
1387:  BCF    03.5
1388:  CALL   16D
1389:  BSF    0A.4
138A:  BTFSC  27.7
138B:  BSF    0B.7
138C:  MOVLW  30
138D:  ADDWF  78,W
138E:  MOVWF  4B
....................             message1[13] = 223; // Degree symbol 
138F:  MOVLW  DF
1390:  MOVWF  3C
....................             // message1 --> Sicaklik bilgisi 
....................             // mesaage2 --> Nem bilgisi 
....................               printf(lcd_putc,"\f"); 
1391:  MOVLW  0C
1392:  MOVWF  72
1393:  BCF    0A.4
1394:  CALL   702
1395:  BSF    0A.4
....................    printf(lcd_putc, "dht2..."); 
1396:  MOVLW  7F
1397:  BSF    03.6
1398:  MOVWF  0D
1399:  MOVLW  05
139A:  MOVWF  0F
139B:  BCF    0A.4
139C:  BCF    03.6
139D:  CALL   726
139E:  BSF    0A.4
....................             // int to char 
....................             if(message2[9] == '0')        fanNem = 0; 
139F:  MOVF   48,W
13A0:  SUBLW  30
13A1:  BTFSS  03.2
13A2:  GOTO   3A5
13A3:  CLRF   62
13A4:  GOTO   3E3
....................             else if(message2[9] == '1')   fanNem = 10; 
13A5:  MOVF   48,W
13A6:  SUBLW  31
13A7:  BTFSS  03.2
13A8:  GOTO   3AC
13A9:  MOVLW  0A
13AA:  MOVWF  62
13AB:  GOTO   3E3
....................             else if(message2[9] == '2')   fanNem = 20; 
13AC:  MOVF   48,W
13AD:  SUBLW  32
13AE:  BTFSS  03.2
13AF:  GOTO   3B3
13B0:  MOVLW  14
13B1:  MOVWF  62
13B2:  GOTO   3E3
....................             else if(message2[9] == '3')   fanNem = 30; 
13B3:  MOVF   48,W
13B4:  SUBLW  33
13B5:  BTFSS  03.2
13B6:  GOTO   3BA
13B7:  MOVLW  1E
13B8:  MOVWF  62
13B9:  GOTO   3E3
....................             else if(message2[9] == '4')   fanNem = 40; 
13BA:  MOVF   48,W
13BB:  SUBLW  34
13BC:  BTFSS  03.2
13BD:  GOTO   3C1
13BE:  MOVLW  28
13BF:  MOVWF  62
13C0:  GOTO   3E3
....................             else if(message2[9] == '5')   fanNem = 50; 
13C1:  MOVF   48,W
13C2:  SUBLW  35
13C3:  BTFSS  03.2
13C4:  GOTO   3C8
13C5:  MOVLW  32
13C6:  MOVWF  62
13C7:  GOTO   3E3
....................             else if(message2[9] == '6')   fanNem = 60; 
13C8:  MOVF   48,W
13C9:  SUBLW  36
13CA:  BTFSS  03.2
13CB:  GOTO   3CF
13CC:  MOVLW  3C
13CD:  MOVWF  62
13CE:  GOTO   3E3
....................             else if(message2[9] == '7')   fanNem = 70; 
13CF:  MOVF   48,W
13D0:  SUBLW  37
13D1:  BTFSS  03.2
13D2:  GOTO   3D6
13D3:  MOVLW  46
13D4:  MOVWF  62
13D5:  GOTO   3E3
....................             else if(message2[9] == '8')   fanNem = 80; 
13D6:  MOVF   48,W
13D7:  SUBLW  38
13D8:  BTFSS  03.2
13D9:  GOTO   3DD
13DA:  MOVLW  50
13DB:  MOVWF  62
13DC:  GOTO   3E3
....................             else if(message2[9] == '9')   fanNem = 90; 
13DD:  MOVF   48,W
13DE:  SUBLW  39
13DF:  BTFSS  03.2
13E0:  GOTO   3E3
13E1:  MOVLW  5A
13E2:  MOVWF  62
....................              
....................             if(message2[10] == '0')        fanNem += 0; 
13E3:  MOVF   49,W
13E4:  SUBLW  30
13E5:  BTFSC  03.2
13E6:  GOTO   425
....................             else if(message2[10] == '1')   fanNem += 1; 
13E7:  MOVF   49,W
13E8:  SUBLW  31
13E9:  BTFSS  03.2
13EA:  GOTO   3EE
13EB:  MOVLW  01
13EC:  ADDWF  62,F
13ED:  GOTO   425
....................             else if(message2[10] == '2')   fanNem += 2; 
13EE:  MOVF   49,W
13EF:  SUBLW  32
13F0:  BTFSS  03.2
13F1:  GOTO   3F5
13F2:  MOVLW  02
13F3:  ADDWF  62,F
13F4:  GOTO   425
....................             else if(message2[10] == '3')   fanNem += 3; 
13F5:  MOVF   49,W
13F6:  SUBLW  33
13F7:  BTFSS  03.2
13F8:  GOTO   3FC
13F9:  MOVLW  03
13FA:  ADDWF  62,F
13FB:  GOTO   425
....................             else if(message2[10] == '4')   fanNem += 4; 
13FC:  MOVF   49,W
13FD:  SUBLW  34
13FE:  BTFSS  03.2
13FF:  GOTO   403
1400:  MOVLW  04
1401:  ADDWF  62,F
1402:  GOTO   425
....................             else if(message2[10] == '5')   fanNem += 5; 
1403:  MOVF   49,W
1404:  SUBLW  35
1405:  BTFSS  03.2
1406:  GOTO   40A
1407:  MOVLW  05
1408:  ADDWF  62,F
1409:  GOTO   425
....................             else if(message2[10] == '6')   fanNem += 6; 
140A:  MOVF   49,W
140B:  SUBLW  36
140C:  BTFSS  03.2
140D:  GOTO   411
140E:  MOVLW  06
140F:  ADDWF  62,F
1410:  GOTO   425
....................             else if(message2[10] == '7')   fanNem += 7; 
1411:  MOVF   49,W
1412:  SUBLW  37
1413:  BTFSS  03.2
1414:  GOTO   418
1415:  MOVLW  07
1416:  ADDWF  62,F
1417:  GOTO   425
....................             else if(message2[10] == '8')   fanNem += 8; 
1418:  MOVF   49,W
1419:  SUBLW  38
141A:  BTFSS  03.2
141B:  GOTO   41F
141C:  MOVLW  08
141D:  ADDWF  62,F
141E:  GOTO   425
....................             else if(message2[10] == '9')   fanNem += 9; 
141F:  MOVF   49,W
1420:  SUBLW  39
1421:  BTFSS  03.2
1422:  GOTO   425
1423:  MOVLW  09
1424:  ADDWF  62,F
....................              
....................             // Fan Sýcaklýk 
....................             if(message1[9] == '0')        fanSicaklik = 0; 
1425:  MOVF   38,W
1426:  SUBLW  30
1427:  BTFSS  03.2
1428:  GOTO   42B
1429:  CLRF   63
142A:  GOTO   469
....................             else if(message1[9] == '1')   fanSicaklik = 10; 
142B:  MOVF   38,W
142C:  SUBLW  31
142D:  BTFSS  03.2
142E:  GOTO   432
142F:  MOVLW  0A
1430:  MOVWF  63
1431:  GOTO   469
....................             else if(message1[9] == '2')   fanSicaklik = 20; 
1432:  MOVF   38,W
1433:  SUBLW  32
1434:  BTFSS  03.2
1435:  GOTO   439
1436:  MOVLW  14
1437:  MOVWF  63
1438:  GOTO   469
....................             else if(message1[9] == '3')   fanSicaklik = 30; 
1439:  MOVF   38,W
143A:  SUBLW  33
143B:  BTFSS  03.2
143C:  GOTO   440
143D:  MOVLW  1E
143E:  MOVWF  63
143F:  GOTO   469
....................             else if(message1[9] == '4')   fanSicaklik = 40; 
1440:  MOVF   38,W
1441:  SUBLW  34
1442:  BTFSS  03.2
1443:  GOTO   447
1444:  MOVLW  28
1445:  MOVWF  63
1446:  GOTO   469
....................             else if(message1[9] == '5')   fanSicaklik = 50; 
1447:  MOVF   38,W
1448:  SUBLW  35
1449:  BTFSS  03.2
144A:  GOTO   44E
144B:  MOVLW  32
144C:  MOVWF  63
144D:  GOTO   469
....................             else if(message1[9] == '6')   fanSicaklik = 60; 
144E:  MOVF   38,W
144F:  SUBLW  36
1450:  BTFSS  03.2
1451:  GOTO   455
1452:  MOVLW  3C
1453:  MOVWF  63
1454:  GOTO   469
....................             else if(message1[9] == '7')   fanSicaklik = 70; 
1455:  MOVF   38,W
1456:  SUBLW  37
1457:  BTFSS  03.2
1458:  GOTO   45C
1459:  MOVLW  46
145A:  MOVWF  63
145B:  GOTO   469
....................             else if(message1[9] == '8')   fanSicaklik = 80; 
145C:  MOVF   38,W
145D:  SUBLW  38
145E:  BTFSS  03.2
145F:  GOTO   463
1460:  MOVLW  50
1461:  MOVWF  63
1462:  GOTO   469
....................             else if(message1[9] == '9')   fanSicaklik = 90; 
1463:  MOVF   38,W
1464:  SUBLW  39
1465:  BTFSS  03.2
1466:  GOTO   469
1467:  MOVLW  5A
1468:  MOVWF  63
....................              
....................             if(message2[10] == '0')        fanSicaklik += 0; 
1469:  MOVF   49,W
146A:  SUBLW  30
146B:  BTFSC  03.2
146C:  GOTO   4AB
....................             else if(message1[10] == '1')   fanSicaklik += 1; 
146D:  MOVF   39,W
146E:  SUBLW  31
146F:  BTFSS  03.2
1470:  GOTO   474
1471:  MOVLW  01
1472:  ADDWF  63,F
1473:  GOTO   4AB
....................             else if(message1[10] == '2')   fanSicaklik += 2; 
1474:  MOVF   39,W
1475:  SUBLW  32
1476:  BTFSS  03.2
1477:  GOTO   47B
1478:  MOVLW  02
1479:  ADDWF  63,F
147A:  GOTO   4AB
....................             else if(message1[10] == '3')   fanSicaklik += 3; 
147B:  MOVF   39,W
147C:  SUBLW  33
147D:  BTFSS  03.2
147E:  GOTO   482
147F:  MOVLW  03
1480:  ADDWF  63,F
1481:  GOTO   4AB
....................             else if(message1[10] == '4')   fanSicaklik += 4; 
1482:  MOVF   39,W
1483:  SUBLW  34
1484:  BTFSS  03.2
1485:  GOTO   489
1486:  MOVLW  04
1487:  ADDWF  63,F
1488:  GOTO   4AB
....................             else if(message1[10] == '5')   fanSicaklik += 5; 
1489:  MOVF   39,W
148A:  SUBLW  35
148B:  BTFSS  03.2
148C:  GOTO   490
148D:  MOVLW  05
148E:  ADDWF  63,F
148F:  GOTO   4AB
....................             else if(message1[10] == '6')   fanSicaklik += 6; 
1490:  MOVF   39,W
1491:  SUBLW  36
1492:  BTFSS  03.2
1493:  GOTO   497
1494:  MOVLW  06
1495:  ADDWF  63,F
1496:  GOTO   4AB
....................             else if(message1[10] == '7')   fanSicaklik += 7; 
1497:  MOVF   39,W
1498:  SUBLW  37
1499:  BTFSS  03.2
149A:  GOTO   49E
149B:  MOVLW  07
149C:  ADDWF  63,F
149D:  GOTO   4AB
....................             else if(message1[10] == '8')   fanSicaklik += 8; 
149E:  MOVF   39,W
149F:  SUBLW  38
14A0:  BTFSS  03.2
14A1:  GOTO   4A5
14A2:  MOVLW  08
14A3:  ADDWF  63,F
14A4:  GOTO   4AB
....................             else if(message1[10] == '9')   fanSicaklik += 9; 
14A5:  MOVF   39,W
14A6:  SUBLW  39
14A7:  BTFSS  03.2
14A8:  GOTO   4AB
14A9:  MOVLW  09
14AA:  ADDWF  63,F
....................              
....................           } 
14AB:  GOTO   4CA
....................             else 
....................             { 
....................                if(10 >saniye > 5 ) 
14AC:  MOVF   55,W
14AD:  SUBLW  09
14AE:  BTFSC  03.0
14AF:  GOTO   4B2
14B0:  MOVLW  00
14B1:  GOTO   4B3
14B2:  MOVLW  01
14B3:  SUBLW  05
14B4:  BTFSC  03.0
14B5:  GOTO   4CA
....................                { 
....................                    lcd_putc('\f');                       // LCD clear 
14B6:  MOVLW  0C
14B7:  MOVWF  72
14B8:  BCF    0A.4
14B9:  CALL   702
14BA:  BSF    0A.4
....................                    lcd_gotoxy(1, 1);                     // Go to column 1 row 1 
14BB:  MOVLW  01
14BC:  MOVWF  73
14BD:  MOVWF  74
14BE:  BCF    0A.4
14BF:  CALL   6DF
14C0:  BSF    0A.4
....................                    lcd_putc("Checksum Error!"); 
14C1:  MOVLW  83
14C2:  BSF    03.6
14C3:  MOVWF  0D
14C4:  MOVLW  05
14C5:  MOVWF  0F
14C6:  BCF    0A.4
14C7:  BCF    03.6
14C8:  CALL   726
14C9:  BSF    0A.4
....................                } 
....................              
....................             } 
....................           } 
....................         } 
14CA:  GOTO   4FA
....................         else { 
....................          if(20 >saniye > 10 ) 
14CB:  MOVF   55,W
14CC:  SUBLW  13
14CD:  BTFSC  03.0
14CE:  GOTO   4D1
14CF:  MOVLW  00
14D0:  GOTO   4D2
14D1:  MOVLW  01
14D2:  SUBLW  0A
14D3:  BTFSC  03.0
14D4:  GOTO   4FA
....................          { 
....................             lcd_putc('\f');                          // LCD clear 
14D5:  MOVLW  0C
14D6:  MOVWF  72
14D7:  BCF    0A.4
14D8:  CALL   702
14D9:  BSF    0A.4
....................             lcd_gotoxy(3, 1);                        // Go to column 3 row 1 
14DA:  MOVLW  03
14DB:  MOVWF  73
14DC:  MOVLW  01
14DD:  MOVWF  74
14DE:  BCF    0A.4
14DF:  CALL   6DF
14E0:  BSF    0A.4
....................             lcd_putc("No response"); 
14E1:  MOVLW  8B
14E2:  BSF    03.6
14E3:  MOVWF  0D
14E4:  MOVLW  05
14E5:  MOVWF  0F
14E6:  BCF    0A.4
14E7:  BCF    03.6
14E8:  CALL   726
14E9:  BSF    0A.4
....................             lcd_gotoxy(1, 2);                        // Go to column 1 row 2 
14EA:  MOVLW  01
14EB:  MOVWF  73
14EC:  MOVLW  02
14ED:  MOVWF  74
14EE:  BCF    0A.4
14EF:  CALL   6DF
14F0:  BSF    0A.4
....................             lcd_putc("from the DHT11"); 
14F1:  MOVLW  91
14F2:  BSF    03.6
14F3:  MOVWF  0D
14F4:  MOVLW  05
14F5:  MOVWF  0F
14F6:  BCF    0A.4
14F7:  BCF    03.6
14F8:  CALL   726
14F9:  BSF    0A.4
....................          } 
....................              
....................         } 
....................                 
....................              
....................              
....................              
....................       // Genel Ekran temizleme 
....................       lcd_putc('\f'); 
14FA:  MOVLW  0C
14FB:  MOVWF  72
14FC:  BCF    0A.4
14FD:  CALL   702
14FE:  BSF    0A.4
....................  
....................       // Su pompasinin Kontrolý  
....................       if(input(PIN_C3) == 1)  output_high(PIN_B0); // SuPompasi Aktif 
14FF:  BTFSS  07.3
1500:  GOTO   503
1501:  BSF    06.0
1502:  GOTO   504
....................       else                    output_low(PIN_B0); 
1503:  BCF    06.0
....................        
....................        
....................       //  Fan kontorol 
....................       if(bitki == '1') 
1504:  MOVF   59,W
1505:  SUBLW  31
1506:  BTFSS  03.2
1507:  GOTO   510
....................       {   
....................          // 
....................          if(fanNem > 70)   output_high(PIN_B2);  
1508:  MOVF   62,W
1509:  SUBLW  46
150A:  BTFSC  03.0
150B:  GOTO   50E
150C:  BSF    06.2
150D:  GOTO   50F
....................          else              output_low (PIN_B2); 
150E:  BCF    06.2
....................       } 
150F:  GOTO   527
....................       else if(bitki == '2') 
1510:  MOVF   59,W
1511:  SUBLW  32
1512:  BTFSS  03.2
1513:  GOTO   51C
....................       { 
....................          if(fanNem > 75)   output_high(PIN_B2);  
1514:  MOVF   62,W
1515:  SUBLW  4B
1516:  BTFSC  03.0
1517:  GOTO   51A
1518:  BSF    06.2
1519:  GOTO   51B
....................          else              output_low (PIN_B2); 
151A:  BCF    06.2
....................       } 
151B:  GOTO   527
....................       else if(bitki == '3') 
151C:  MOVF   59,W
151D:  SUBLW  33
151E:  BTFSS  03.2
151F:  GOTO   527
....................       { 
....................          if(fanNem > 80)   output_high(PIN_B2);  
1520:  MOVF   62,W
1521:  SUBLW  50
1522:  BTFSC  03.0
1523:  GOTO   526
1524:  BSF    06.2
1525:  GOTO   527
....................          else              output_low (PIN_B2); 
1526:  BCF    06.2
....................       } 
....................        
....................        
....................       // Led kontrol 
....................       // Sadece Tohum Zamaninda Ve Mevye Zamaninda  
....................        
....................       if(ldr > 8) // Gece degilse. 
1527:  MOVF   60,W
1528:  SUBLW  08
1529:  BTFSC  03.0
152A:  GOTO   545
....................       { 
....................          if(durum3 == '1') 
152B:  MOVF   5C,W
152C:  SUBLW  31
152D:  BTFSS  03.2
152E:  GOTO   537
....................          { 
....................             if(ldr < 70)  output_high(PIN_B3); 
152F:  MOVF   60,W
1530:  SUBLW  45
1531:  BTFSS  03.0
1532:  GOTO   535
1533:  BSF    06.3
1534:  GOTO   536
....................             else          output_low (PIN_B3); 
1535:  BCF    06.3
....................          } 
1536:  GOTO   544
....................          else if(durum1 == '0') 
1537:  MOVF   5A,W
1538:  SUBLW  30
1539:  BTFSS  03.2
153A:  GOTO   53D
....................          { 
....................             output_low (PIN_B3); 
153B:  BCF    06.3
....................          } 
153C:  GOTO   544
....................          else 
....................          { 
....................             if(ldr < 30) output_high(PIN_B3); 
153D:  MOVF   60,W
153E:  SUBLW  1D
153F:  BTFSS  03.0
1540:  GOTO   543
1541:  BSF    06.3
1542:  GOTO   544
....................             else         output_low (PIN_B3); 
1543:  BCF    06.3
....................          } 
....................       } 
1544:  GOTO   546
....................       else 
....................       { 
....................          output_low (PIN_B3); 
1545:  BCF    06.3
....................       } 
....................        
....................        
....................       // Sistemin Offline durumu 
....................        
....................       if(bitki != '0' ) 
1546:  MOVF   59,W
1547:  SUBLW  30
1548:  BTFSC  03.2
1549:  GOTO   65D
....................       { 
....................          if(saniye > 15) 
154A:  MOVF   55,W
154B:  SUBLW  0F
154C:  BTFSC  03.0
154D:  GOTO   57E
....................          {  // Su deposu seviyesi 
....................              
....................             printf(lcd_putc, "SU DEPOSU SEVIYE"); 
154E:  MOVLW  99
154F:  BSF    03.6
1550:  MOVWF  0D
1551:  MOVLW  05
1552:  MOVWF  0F
1553:  BCF    0A.4
1554:  BCF    03.6
1555:  CALL   726
1556:  BSF    0A.4
....................             lcd_gotoxy(7,2); 
1557:  MOVLW  07
1558:  MOVWF  73
1559:  MOVLW  02
155A:  MOVWF  74
155B:  BCF    0A.4
155C:  CALL   6DF
155D:  BSF    0A.4
....................             lcd_putc("%"); 
155E:  MOVLW  A2
155F:  BSF    03.6
1560:  MOVWF  0D
1561:  MOVLW  05
1562:  MOVWF  0F
1563:  BCF    0A.4
1564:  BCF    03.6
1565:  CALL   726
1566:  BSF    0A.4
....................              printf(lcd_putc, "%d",suSeviye); 
1567:  MOVF   5F,W
1568:  MOVWF  65
1569:  MOVLW  18
156A:  MOVWF  66
156B:  BCF    0A.4
156C:  BSF    0A.3
156D:  CALL   24D
156E:  BSF    0A.4
156F:  BCF    0A.3
....................              
....................             delay_ms(500); 
1570:  MOVLW  02
1571:  MOVWF  65
1572:  MOVLW  FA
1573:  MOVWF  66
1574:  BCF    0A.4
1575:  CALL   771
1576:  BSF    0A.4
1577:  DECFSZ 65,F
1578:  GOTO   572
....................              
....................             if(saniye == 20) saniye = 0; 
1579:  MOVF   55,W
157A:  SUBLW  14
157B:  BTFSC  03.2
157C:  CLRF   55
....................          } 
157D:  GOTO   65C
....................           
....................          else if(saniye > 10) 
157E:  MOVF   55,W
157F:  SUBLW  0A
1580:  BTFSC  03.0
1581:  GOTO   5F1
....................          {  // Toprak sicaklik  ve Nem 
....................           
....................             lcd_gotoxy(1, 1);  
1582:  MOVLW  01
1583:  MOVWF  73
1584:  MOVWF  74
1585:  BCF    0A.4
1586:  CALL   6DF
1587:  BSF    0A.4
....................             printf(lcd_putc, "TOPRAK NEM:"); 
1588:  MOVLW  A3
1589:  BSF    03.6
158A:  MOVWF  0D
158B:  MOVLW  05
158C:  MOVWF  0F
158D:  BCF    0A.4
158E:  BCF    03.6
158F:  CALL   726
1590:  BSF    0A.4
....................             lcd_putc(" %"); 
1591:  MOVLW  A9
1592:  BSF    03.6
1593:  MOVWF  0D
1594:  MOVLW  05
1595:  MOVWF  0F
1596:  BCF    0A.4
1597:  BCF    03.6
1598:  CALL   726
1599:  BSF    0A.4
....................             printf(lcd_putc, "%d",toprakNem); 
159A:  MOVF   5E,W
159B:  MOVWF  65
159C:  MOVLW  18
159D:  MOVWF  66
159E:  BCF    0A.4
159F:  BSF    0A.3
15A0:  CALL   24D
15A1:  BSF    0A.4
15A2:  BCF    0A.3
....................              
....................             if(toprakNemError == 0) 
15A3:  MOVF   61,F
15A4:  BTFSS  03.2
15A5:  GOTO   5D7
....................             { 
....................             lcd_gotoxy(1, 2);   
15A6:  MOVLW  01
15A7:  MOVWF  73
15A8:  MOVLW  02
15A9:  MOVWF  74
15AA:  BCF    0A.4
15AB:  CALL   6DF
15AC:  BSF    0A.4
....................             printf(lcd_putc, "SICAKLIK:%f%cC",temp, x); 
15AD:  MOVLW  AB
15AE:  BSF    03.6
15AF:  MOVWF  0D
15B0:  MOVLW  05
15B1:  MOVWF  0F
15B2:  BCF    03.0
15B3:  MOVLW  09
15B4:  BCF    03.6
15B5:  MOVWF  65
15B6:  BCF    0A.4
15B7:  BSF    0A.3
15B8:  CALL   2C1
15B9:  BSF    0A.4
15BA:  BCF    0A.3
15BB:  MOVLW  89
15BC:  MOVWF  04
15BD:  MOVF   2D,W
15BE:  MOVWF  68
15BF:  MOVF   2C,W
15C0:  MOVWF  67
15C1:  MOVF   2B,W
15C2:  MOVWF  66
15C3:  MOVF   2A,W
15C4:  MOVWF  65
15C5:  MOVLW  02
15C6:  MOVWF  69
15C7:  BCF    0A.4
15C8:  BSF    0A.3
15C9:  GOTO   319
15CA:  BSF    0A.4
15CB:  BCF    0A.3
15CC:  MOVF   57,W
15CD:  MOVWF  72
15CE:  BCF    0A.4
15CF:  CALL   702
15D0:  BSF    0A.4
15D1:  MOVLW  43
15D2:  MOVWF  72
15D3:  BCF    0A.4
15D4:  CALL   702
15D5:  BSF    0A.4
....................             } 
15D6:  GOTO   5E7
....................             else { 
....................             lcd_gotoxy(5, 2);    
15D7:  MOVLW  05
15D8:  MOVWF  73
15D9:  MOVLW  02
15DA:  MOVWF  74
15DB:  BCF    0A.4
15DC:  CALL   6DF
15DD:  BSF    0A.4
....................             printf(lcd_putc, " Error! ");  
15DE:  MOVLW  B3
15DF:  BSF    03.6
15E0:  MOVWF  0D
15E1:  MOVLW  05
15E2:  MOVWF  0F
15E3:  BCF    0A.4
15E4:  BCF    03.6
15E5:  CALL   726
15E6:  BSF    0A.4
....................             } 
....................             delay_ms(500);  
15E7:  MOVLW  02
15E8:  MOVWF  65
15E9:  MOVLW  FA
15EA:  MOVWF  66
15EB:  BCF    0A.4
15EC:  CALL   771
15ED:  BSF    0A.4
15EE:  DECFSZ 65,F
15EF:  GOTO   5E9
....................              
....................          } 
15F0:  GOTO   65C
....................          else if(saniye > 5) 
15F1:  MOVF   55,W
15F2:  SUBLW  05
15F3:  BTFSC  03.0
15F4:  GOTO   613
....................          {      
....................           
....................           
....................             lcd_gotoxy(1, 1);                     // Go to column 1 row 1 
15F5:  MOVLW  01
15F6:  MOVWF  73
15F7:  MOVWF  74
15F8:  BCF    0A.4
15F9:  CALL   6DF
15FA:  BSF    0A.4
....................             printf(lcd_putc, message1);           // Display message1 
15FB:  MOVLW  2F
15FC:  MOVWF  04
15FD:  BCF    03.7
15FE:  BCF    0A.4
15FF:  BSF    0A.3
1600:  CALL   428
1601:  BSF    0A.4
1602:  BCF    0A.3
....................             lcd_gotoxy(1, 2);                     // Go to column 1 row 2 
1603:  MOVLW  01
1604:  MOVWF  73
1605:  MOVLW  02
1606:  MOVWF  74
1607:  BCF    0A.4
1608:  CALL   6DF
1609:  BSF    0A.4
....................             printf(lcd_putc, message2);  
160A:  MOVLW  3F
160B:  MOVWF  04
160C:  BCF    03.7
160D:  BCF    0A.4
160E:  BSF    0A.3
160F:  CALL   428
1610:  BSF    0A.4
1611:  BCF    0A.3
....................           
....................           
....................          } 
1612:  GOTO   65C
....................          else 
....................          {  //Isik Siddeti 
....................              
....................             lcd_gotoxy(1, 1);  
1613:  MOVLW  01
1614:  MOVWF  73
1615:  MOVWF  74
1616:  BCF    0A.4
1617:  CALL   6DF
1618:  BSF    0A.4
....................             printf(lcd_putc, "  ISIK SIDDETI"); 
1619:  MOVLW  B8
161A:  BSF    03.6
161B:  MOVWF  0D
161C:  MOVLW  05
161D:  MOVWF  0F
161E:  BCF    0A.4
161F:  BCF    03.6
1620:  CALL   726
1621:  BSF    0A.4
....................             lcd_gotoxy(2,2); 
1622:  MOVLW  02
1623:  MOVWF  73
1624:  MOVWF  74
1625:  BCF    0A.4
1626:  CALL   6DF
1627:  BSF    0A.4
....................             printf(lcd_putc, ":%d Durum:%c%c%c", ldr,durum1,durum2,durum3); 
1628:  MOVLW  3A
1629:  MOVWF  72
162A:  BCF    0A.4
162B:  CALL   702
162C:  BSF    0A.4
162D:  MOVF   60,W
162E:  MOVWF  65
162F:  MOVLW  18
1630:  MOVWF  66
1631:  BCF    0A.4
1632:  BSF    0A.3
1633:  CALL   24D
1634:  BSF    0A.4
1635:  BCF    0A.3
1636:  MOVLW  C1
1637:  BSF    03.6
1638:  MOVWF  0D
1639:  MOVLW  05
163A:  MOVWF  0F
163B:  BSF    03.0
163C:  MOVLW  07
163D:  BCF    03.6
163E:  MOVWF  65
163F:  BCF    0A.4
1640:  BSF    0A.3
1641:  CALL   2C1
1642:  BSF    0A.4
1643:  BCF    0A.3
1644:  MOVF   5A,W
1645:  MOVWF  72
1646:  BCF    0A.4
1647:  CALL   702
1648:  BSF    0A.4
1649:  MOVF   5B,W
164A:  MOVWF  72
164B:  BCF    0A.4
164C:  CALL   702
164D:  BSF    0A.4
164E:  MOVF   5C,W
164F:  MOVWF  72
1650:  BCF    0A.4
1651:  CALL   702
1652:  BSF    0A.4
....................              
....................             delay_ms(500); 
1653:  MOVLW  02
1654:  MOVWF  65
1655:  MOVLW  FA
1656:  MOVWF  66
1657:  BCF    0A.4
1658:  CALL   771
1659:  BSF    0A.4
165A:  DECFSZ 65,F
165B:  GOTO   655
....................              
....................          } 
....................           
....................           
....................           
.................... //-----------          
....................       } 
165C:  GOTO   66B
....................       else 
....................       { 
....................       printf(lcd_putc,"Bitki Secimi\nYapiniz..."); 
165D:  MOVLW  C9
165E:  BSF    03.6
165F:  MOVWF  0D
1660:  MOVLW  05
1661:  MOVWF  0F
1662:  BCF    0A.4
1663:  BCF    03.6
1664:  CALL   726
1665:  BSF    0A.4
....................       delay_ms(50); 
1666:  MOVLW  32
1667:  MOVWF  66
1668:  BCF    0A.4
1669:  CALL   771
166A:  BSF    0A.4
....................        
....................       } 
166B:  GOTO   1C4
....................    } 
.................... } 
....................  
166C:  SLEEP
....................  

Configuration Fuses:
   Word  1: 3F72   HS NOWDT PUT BROWNOUT NOLVP NOCPD NOWRT NODEBUG NOPROTECT
